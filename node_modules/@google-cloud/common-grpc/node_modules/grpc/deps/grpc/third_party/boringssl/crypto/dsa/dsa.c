/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 *
 * The DSS routines are based on patches supplied by
 * Steven Schoch <schoch@sheba.arc.nasa.gov>. */

#include <openssl/dsa.h>

#include <string.h>

#include <openssl/bn.h>
#include <openssl/dh.h>
#include <openssl/digest.h>
#include <openssl/engine.h>
#include <openssl/err.h>
#include <openssl/ex_data.h>
#include <openssl/mem.h>
#include <openssl/rand.h>
#include <openssl/sha.h>
#include <openssl/thread.h>

#include "../bn/internal.h"
#include "../internal.h"


#define OPENSSL_DSA_MAX_MODULUS_BITS 10000

/* Primality test according to FIPS PUB 186[-1], Appendix 2.1: 50 rounds of
 * Rabin-Miller */
#define DSS_prime_checks 50

static CRYPTO_EX_DATA_CLASS g_ex_data_class = CRYPTO_EX_DATA_CLASS_INIT;

DSA *DSA_new(void) ***REMOVED***
  DSA *dsa = OPENSSL_malloc(sizeof(DSA));
  if (dsa == NULL) ***REMOVED***
    OPENSSL_PUT_ERROR(DSA, ERR_R_MALLOC_FAILURE);
    return NULL;
  ***REMOVED***

  OPENSSL_memset(dsa, 0, sizeof(DSA));

  dsa->references = 1;

  CRYPTO_MUTEX_init(&dsa->method_mont_lock);
  CRYPTO_new_ex_data(&dsa->ex_data);

  return dsa;
***REMOVED***

void DSA_free(DSA *dsa) ***REMOVED***
  if (dsa == NULL) ***REMOVED***
    return;
  ***REMOVED***

  if (!CRYPTO_refcount_dec_and_test_zero(&dsa->references)) ***REMOVED***
    return;
  ***REMOVED***

  CRYPTO_free_ex_data(&g_ex_data_class, dsa, &dsa->ex_data);

  BN_clear_free(dsa->p);
  BN_clear_free(dsa->q);
  BN_clear_free(dsa->g);
  BN_clear_free(dsa->pub_key);
  BN_clear_free(dsa->priv_key);
  BN_clear_free(dsa->kinv);
  BN_clear_free(dsa->r);
  BN_MONT_CTX_free(dsa->method_mont_p);
  BN_MONT_CTX_free(dsa->method_mont_q);
  CRYPTO_MUTEX_cleanup(&dsa->method_mont_lock);
  OPENSSL_free(dsa);
***REMOVED***

int DSA_up_ref(DSA *dsa) ***REMOVED***
  CRYPTO_refcount_inc(&dsa->references);
  return 1;
***REMOVED***

void DSA_get0_key(const DSA *dsa, const BIGNUM **out_pub_key,
                  const BIGNUM **out_priv_key) ***REMOVED***
  if (out_pub_key != NULL) ***REMOVED***
    *out_pub_key = dsa->pub_key;
  ***REMOVED***
  if (out_priv_key != NULL) ***REMOVED***
    *out_priv_key = dsa->priv_key;
  ***REMOVED***
***REMOVED***

void DSA_get0_pqg(const DSA *dsa, const BIGNUM **out_p, const BIGNUM **out_q,
                  const BIGNUM **out_g) ***REMOVED***
  if (out_p != NULL) ***REMOVED***
    *out_p = dsa->p;
  ***REMOVED***
  if (out_q != NULL) ***REMOVED***
    *out_q = dsa->q;
  ***REMOVED***
  if (out_g != NULL) ***REMOVED***
    *out_g = dsa->g;
  ***REMOVED***
***REMOVED***

int DSA_generate_parameters_ex(DSA *dsa, unsigned bits, const uint8_t *seed_in,
                               size_t seed_len, int *out_counter,
                               unsigned long *out_h, BN_GENCB *cb) ***REMOVED***
  int ok = 0;
  unsigned char seed[SHA256_DIGEST_LENGTH];
  unsigned char md[SHA256_DIGEST_LENGTH];
  unsigned char buf[SHA256_DIGEST_LENGTH], buf2[SHA256_DIGEST_LENGTH];
  BIGNUM *r0, *W, *X, *c, *test;
  BIGNUM *g = NULL, *q = NULL, *p = NULL;
  BN_MONT_CTX *mont = NULL;
  int k, n = 0, m = 0;
  unsigned i;
  int counter = 0;
  int r = 0;
  BN_CTX *ctx = NULL;
  unsigned int h = 2;
  unsigned qsize;
  const EVP_MD *evpmd;

  evpmd = (bits >= 2048) ? EVP_sha256() : EVP_sha1();
  qsize = EVP_MD_size(evpmd);

  if (bits < 512) ***REMOVED***
    bits = 512;
  ***REMOVED***

  bits = (bits + 63) / 64 * 64;

  if (seed_in != NULL) ***REMOVED***
    if (seed_len < (size_t)qsize) ***REMOVED***
      return 0;
    ***REMOVED***
    if (seed_len > (size_t)qsize) ***REMOVED***
      /* Only consume as much seed as is expected. */
      seed_len = qsize;
    ***REMOVED***
    OPENSSL_memcpy(seed, seed_in, seed_len);
  ***REMOVED***

  ctx = BN_CTX_new();
  if (ctx == NULL) ***REMOVED***
    goto err;
  ***REMOVED***
  BN_CTX_start(ctx);

  mont = BN_MONT_CTX_new();
  if (mont == NULL) ***REMOVED***
    goto err;
  ***REMOVED***

  r0 = BN_CTX_get(ctx);
  g = BN_CTX_get(ctx);
  W = BN_CTX_get(ctx);
  q = BN_CTX_get(ctx);
  X = BN_CTX_get(ctx);
  c = BN_CTX_get(ctx);
  p = BN_CTX_get(ctx);
  test = BN_CTX_get(ctx);

  if (test == NULL || !BN_lshift(test, BN_value_one(), bits - 1)) ***REMOVED***
    goto err;
  ***REMOVED***

  for (;;) ***REMOVED***
    /* Find q. */
    for (;;) ***REMOVED***
      /* step 1 */
      if (!BN_GENCB_call(cb, 0, m++)) ***REMOVED***
        goto err;
      ***REMOVED***

      int use_random_seed = (seed_in == NULL);
      if (use_random_seed) ***REMOVED***
        if (!RAND_bytes(seed, qsize)) ***REMOVED***
          goto err;
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        /* If we come back through, use random seed next time. */
        seed_in = NULL;
      ***REMOVED***
      OPENSSL_memcpy(buf, seed, qsize);
      OPENSSL_memcpy(buf2, seed, qsize);
      /* precompute "SEED + 1" for step 7: */
      for (i = qsize - 1; i < qsize; i--) ***REMOVED***
        buf[i]++;
        if (buf[i] != 0) ***REMOVED***
          break;
        ***REMOVED***
      ***REMOVED***

      /* step 2 */
      if (!EVP_Digest(seed, qsize, md, NULL, evpmd, NULL) ||
          !EVP_Digest(buf, qsize, buf2, NULL, evpmd, NULL)) ***REMOVED***
        goto err;
      ***REMOVED***
      for (i = 0; i < qsize; i++) ***REMOVED***
        md[i] ^= buf2[i];
      ***REMOVED***

      /* step 3 */
      md[0] |= 0x80;
      md[qsize - 1] |= 0x01;
      if (!BN_bin2bn(md, qsize, q)) ***REMOVED***
        goto err;
      ***REMOVED***

      /* step 4 */
      r = BN_is_prime_fasttest_ex(q, DSS_prime_checks, ctx, use_random_seed, cb);
      if (r > 0) ***REMOVED***
        break;
      ***REMOVED***
      if (r != 0) ***REMOVED***
        goto err;
      ***REMOVED***

      /* do a callback call */
      /* step 5 */
    ***REMOVED***

    if (!BN_GENCB_call(cb, 2, 0) || !BN_GENCB_call(cb, 3, 0)) ***REMOVED***
      goto err;
    ***REMOVED***

    /* step 6 */
    counter = 0;
    /* "offset = 2" */

    n = (bits - 1) / 160;

    for (;;) ***REMOVED***
      if ((counter != 0) && !BN_GENCB_call(cb, 0, counter)) ***REMOVED***
        goto err;
      ***REMOVED***

      /* step 7 */
      BN_zero(W);
      /* now 'buf' contains "SEED + offset - 1" */
      for (k = 0; k <= n; k++) ***REMOVED***
        /* obtain "SEED + offset + k" by incrementing: */
        for (i = qsize - 1; i < qsize; i--) ***REMOVED***
          buf[i]++;
          if (buf[i] != 0) ***REMOVED***
            break;
          ***REMOVED***
        ***REMOVED***

        if (!EVP_Digest(buf, qsize, md, NULL, evpmd, NULL)) ***REMOVED***
          goto err;
        ***REMOVED***

        /* step 8 */
        if (!BN_bin2bn(md, qsize, r0) ||
            !BN_lshift(r0, r0, (qsize << 3) * k) ||
            !BN_add(W, W, r0)) ***REMOVED***
          goto err;
        ***REMOVED***
      ***REMOVED***

      /* more of step 8 */
      if (!BN_mask_bits(W, bits - 1) ||
          !BN_copy(X, W) ||
          !BN_add(X, X, test)) ***REMOVED***
        goto err;
      ***REMOVED***

      /* step 9 */
      if (!BN_lshift1(r0, q) ||
          !BN_mod(c, X, r0, ctx) ||
          !BN_sub(r0, c, BN_value_one()) ||
          !BN_sub(p, X, r0)) ***REMOVED***
        goto err;
      ***REMOVED***

      /* step 10 */
      if (BN_cmp(p, test) >= 0) ***REMOVED***
        /* step 11 */
        r = BN_is_prime_fasttest_ex(p, DSS_prime_checks, ctx, 1, cb);
        if (r > 0) ***REMOVED***
          goto end; /* found it */
        ***REMOVED***
        if (r != 0) ***REMOVED***
          goto err;
        ***REMOVED***
      ***REMOVED***

      /* step 13 */
      counter++;
      /* "offset = offset + n + 1" */

      /* step 14 */
      if (counter >= 4096) ***REMOVED***
        break;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
end:
  if (!BN_GENCB_call(cb, 2, 1)) ***REMOVED***
    goto err;
  ***REMOVED***

  /* We now need to generate g */
  /* Set r0=(p-1)/q */
  if (!BN_sub(test, p, BN_value_one()) ||
      !BN_div(r0, NULL, test, q, ctx)) ***REMOVED***
    goto err;
  ***REMOVED***

  if (!BN_set_word(test, h) ||
      !BN_MONT_CTX_set(mont, p, ctx)) ***REMOVED***
    goto err;
  ***REMOVED***

  for (;;) ***REMOVED***
    /* g=test^r0%p */
    if (!BN_mod_exp_mont(g, test, r0, p, ctx, mont)) ***REMOVED***
      goto err;
    ***REMOVED***
    if (!BN_is_one(g)) ***REMOVED***
      break;
    ***REMOVED***
    if (!BN_add(test, test, BN_value_one())) ***REMOVED***
      goto err;
    ***REMOVED***
    h++;
  ***REMOVED***

  if (!BN_GENCB_call(cb, 3, 1)) ***REMOVED***
    goto err;
  ***REMOVED***

  ok = 1;

err:
  if (ok) ***REMOVED***
    BN_free(dsa->p);
    BN_free(dsa->q);
    BN_free(dsa->g);
    dsa->p = BN_dup(p);
    dsa->q = BN_dup(q);
    dsa->g = BN_dup(g);
    if (dsa->p == NULL || dsa->q == NULL || dsa->g == NULL) ***REMOVED***
      ok = 0;
      goto err;
    ***REMOVED***
    if (out_counter != NULL) ***REMOVED***
      *out_counter = counter;
    ***REMOVED***
    if (out_h != NULL) ***REMOVED***
      *out_h = h;
    ***REMOVED***
  ***REMOVED***

  if (ctx) ***REMOVED***
    BN_CTX_end(ctx);
    BN_CTX_free(ctx);
  ***REMOVED***

  BN_MONT_CTX_free(mont);

  return ok;
***REMOVED***

DSA *DSAparams_dup(const DSA *dsa) ***REMOVED***
  DSA *ret = DSA_new();
  if (ret == NULL) ***REMOVED***
    return NULL;
  ***REMOVED***
  ret->p = BN_dup(dsa->p);
  ret->q = BN_dup(dsa->q);
  ret->g = BN_dup(dsa->g);
  if (ret->p == NULL || ret->q == NULL || ret->g == NULL) ***REMOVED***
    DSA_free(ret);
    return NULL;
  ***REMOVED***
  return ret;
***REMOVED***

int DSA_generate_key(DSA *dsa) ***REMOVED***
  int ok = 0;
  BN_CTX *ctx = NULL;
  BIGNUM *pub_key = NULL, *priv_key = NULL;

  ctx = BN_CTX_new();
  if (ctx == NULL) ***REMOVED***
    goto err;
  ***REMOVED***

  priv_key = dsa->priv_key;
  if (priv_key == NULL) ***REMOVED***
    priv_key = BN_new();
    if (priv_key == NULL) ***REMOVED***
      goto err;
    ***REMOVED***
  ***REMOVED***

  if (!BN_rand_range_ex(priv_key, 1, dsa->q)) ***REMOVED***
    goto err;
  ***REMOVED***

  pub_key = dsa->pub_key;
  if (pub_key == NULL) ***REMOVED***
    pub_key = BN_new();
    if (pub_key == NULL) ***REMOVED***
      goto err;
    ***REMOVED***
  ***REMOVED***

  if (!BN_MONT_CTX_set_locked(&dsa->method_mont_p, &dsa->method_mont_lock,
                              dsa->p, ctx) ||
      !BN_mod_exp_mont_consttime(pub_key, dsa->g, priv_key, dsa->p, ctx,
                                 dsa->method_mont_p)) ***REMOVED***
    goto err;
  ***REMOVED***

  dsa->priv_key = priv_key;
  dsa->pub_key = pub_key;
  ok = 1;

err:
  if (dsa->pub_key == NULL) ***REMOVED***
    BN_free(pub_key);
  ***REMOVED***
  if (dsa->priv_key == NULL) ***REMOVED***
    BN_free(priv_key);
  ***REMOVED***
  BN_CTX_free(ctx);

  return ok;
***REMOVED***

DSA_SIG *DSA_SIG_new(void) ***REMOVED***
  DSA_SIG *sig;
  sig = OPENSSL_malloc(sizeof(DSA_SIG));
  if (!sig) ***REMOVED***
    return NULL;
  ***REMOVED***
  sig->r = NULL;
  sig->s = NULL;
  return sig;
***REMOVED***

void DSA_SIG_free(DSA_SIG *sig) ***REMOVED***
  if (!sig) ***REMOVED***
    return;
  ***REMOVED***

  BN_free(sig->r);
  BN_free(sig->s);
  OPENSSL_free(sig);
***REMOVED***

DSA_SIG *DSA_do_sign(const uint8_t *digest, size_t digest_len, DSA *dsa) ***REMOVED***
  BIGNUM *kinv = NULL, *r = NULL, *s = NULL;
  BIGNUM m;
  BIGNUM xr;
  BN_CTX *ctx = NULL;
  int reason = ERR_R_BN_LIB;
  DSA_SIG *ret = NULL;
  int noredo = 0;

  BN_init(&m);
  BN_init(&xr);

  if (!dsa->p || !dsa->q || !dsa->g) ***REMOVED***
    reason = DSA_R_MISSING_PARAMETERS;
    goto err;
  ***REMOVED***

  s = BN_new();
  if (s == NULL) ***REMOVED***
    goto err;
  ***REMOVED***
  ctx = BN_CTX_new();
  if (ctx == NULL) ***REMOVED***
    goto err;
  ***REMOVED***

redo:
  if (dsa->kinv == NULL || dsa->r == NULL) ***REMOVED***
    if (!DSA_sign_setup(dsa, ctx, &kinv, &r)) ***REMOVED***
      goto err;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    kinv = dsa->kinv;
    dsa->kinv = NULL;
    r = dsa->r;
    dsa->r = NULL;
    noredo = 1;
  ***REMOVED***

  if (digest_len > BN_num_bytes(dsa->q)) ***REMOVED***
    /* if the digest length is greater than the size of q use the
     * BN_num_bits(dsa->q) leftmost bits of the digest, see
     * fips 186-3, 4.2 */
    digest_len = BN_num_bytes(dsa->q);
  ***REMOVED***

  if (BN_bin2bn(digest, digest_len, &m) == NULL) ***REMOVED***
    goto err;
  ***REMOVED***

  /* Compute  s = inv(k) (m + xr) mod q */
  if (!BN_mod_mul(&xr, dsa->priv_key, r, dsa->q, ctx)) ***REMOVED***
    goto err; /* s = xr */
  ***REMOVED***
  if (!BN_add(s, &xr, &m)) ***REMOVED***
    goto err; /* s = m + xr */
  ***REMOVED***
  if (BN_cmp(s, dsa->q) > 0) ***REMOVED***
    if (!BN_sub(s, s, dsa->q)) ***REMOVED***
      goto err;
    ***REMOVED***
  ***REMOVED***
  if (!BN_mod_mul(s, s, kinv, dsa->q, ctx)) ***REMOVED***
    goto err;
  ***REMOVED***

  /* Redo if r or s is zero as required by FIPS 186-3: this is
   * very unlikely. */
  if (BN_is_zero(r) || BN_is_zero(s)) ***REMOVED***
    if (noredo) ***REMOVED***
      reason = DSA_R_NEED_NEW_SETUP_VALUES;
      goto err;
    ***REMOVED***
    goto redo;
  ***REMOVED***
  ret = DSA_SIG_new();
  if (ret == NULL) ***REMOVED***
    goto err;
  ***REMOVED***
  ret->r = r;
  ret->s = s;

err:
  if (ret == NULL) ***REMOVED***
    OPENSSL_PUT_ERROR(DSA, reason);
    BN_free(r);
    BN_free(s);
  ***REMOVED***
  BN_CTX_free(ctx);
  BN_clear_free(&m);
  BN_clear_free(&xr);
  BN_clear_free(kinv);

  return ret;
***REMOVED***

int DSA_do_verify(const uint8_t *digest, size_t digest_len, DSA_SIG *sig,
                  const DSA *dsa) ***REMOVED***
  int valid;
  if (!DSA_do_check_signature(&valid, digest, digest_len, sig, dsa)) ***REMOVED***
    return -1;
  ***REMOVED***
  return valid;
***REMOVED***

int DSA_do_check_signature(int *out_valid, const uint8_t *digest,
                           size_t digest_len, DSA_SIG *sig, const DSA *dsa) ***REMOVED***
  BN_CTX *ctx;
  BIGNUM u1, u2, t1;
  int ret = 0;
  unsigned i;

  *out_valid = 0;

  if (!dsa->p || !dsa->q || !dsa->g) ***REMOVED***
    OPENSSL_PUT_ERROR(DSA, DSA_R_MISSING_PARAMETERS);
    return 0;
  ***REMOVED***

  i = BN_num_bits(dsa->q);
  /* fips 186-3 allows only different sizes for q */
  if (i != 160 && i != 224 && i != 256) ***REMOVED***
    OPENSSL_PUT_ERROR(DSA, DSA_R_BAD_Q_VALUE);
    return 0;
  ***REMOVED***

  if (BN_num_bits(dsa->p) > OPENSSL_DSA_MAX_MODULUS_BITS) ***REMOVED***
    OPENSSL_PUT_ERROR(DSA, DSA_R_MODULUS_TOO_LARGE);
    return 0;
  ***REMOVED***

  BN_init(&u1);
  BN_init(&u2);
  BN_init(&t1);

  ctx = BN_CTX_new();
  if (ctx == NULL) ***REMOVED***
    goto err;
  ***REMOVED***

  if (BN_is_zero(sig->r) || BN_is_negative(sig->r) ||
      BN_ucmp(sig->r, dsa->q) >= 0) ***REMOVED***
    ret = 1;
    goto err;
  ***REMOVED***
  if (BN_is_zero(sig->s) || BN_is_negative(sig->s) ||
      BN_ucmp(sig->s, dsa->q) >= 0) ***REMOVED***
    ret = 1;
    goto err;
  ***REMOVED***

  /* Calculate W = inv(S) mod Q
   * save W in u2 */
  if (BN_mod_inverse(&u2, sig->s, dsa->q, ctx) == NULL) ***REMOVED***
    goto err;
  ***REMOVED***

  /* save M in u1 */
  if (digest_len > (i >> 3)) ***REMOVED***
    /* if the digest length is greater than the size of q use the
     * BN_num_bits(dsa->q) leftmost bits of the digest, see
     * fips 186-3, 4.2 */
    digest_len = (i >> 3);
  ***REMOVED***

  if (BN_bin2bn(digest, digest_len, &u1) == NULL) ***REMOVED***
    goto err;
  ***REMOVED***

  /* u1 = M * w mod q */
  if (!BN_mod_mul(&u1, &u1, &u2, dsa->q, ctx)) ***REMOVED***
    goto err;
  ***REMOVED***

  /* u2 = r * w mod q */
  if (!BN_mod_mul(&u2, sig->r, &u2, dsa->q, ctx)) ***REMOVED***
    goto err;
  ***REMOVED***

  if (!BN_MONT_CTX_set_locked((BN_MONT_CTX **)&dsa->method_mont_p,
                              (CRYPTO_MUTEX *)&dsa->method_mont_lock, dsa->p,
                              ctx)) ***REMOVED***
    goto err;
  ***REMOVED***

  if (!BN_mod_exp2_mont(&t1, dsa->g, &u1, dsa->pub_key, &u2, dsa->p, ctx,
                        dsa->method_mont_p)) ***REMOVED***
    goto err;
  ***REMOVED***

  /* BN_copy(&u1,&t1); */
  /* let u1 = u1 mod q */
  if (!BN_mod(&u1, &t1, dsa->q, ctx)) ***REMOVED***
    goto err;
  ***REMOVED***

  /* V is now in u1.  If the signature is correct, it will be
   * equal to R. */
  *out_valid = BN_ucmp(&u1, sig->r) == 0;
  ret = 1;

err:
  if (ret != 1) ***REMOVED***
    OPENSSL_PUT_ERROR(DSA, ERR_R_BN_LIB);
  ***REMOVED***
  BN_CTX_free(ctx);
  BN_free(&u1);
  BN_free(&u2);
  BN_free(&t1);

  return ret;
***REMOVED***

int DSA_sign(int type, const uint8_t *digest, size_t digest_len,
             uint8_t *out_sig, unsigned int *out_siglen, DSA *dsa) ***REMOVED***
  DSA_SIG *s;

  s = DSA_do_sign(digest, digest_len, dsa);
  if (s == NULL) ***REMOVED***
    *out_siglen = 0;
    return 0;
  ***REMOVED***

  *out_siglen = i2d_DSA_SIG(s, &out_sig);
  DSA_SIG_free(s);
  return 1;
***REMOVED***

int DSA_verify(int type, const uint8_t *digest, size_t digest_len,
               const uint8_t *sig, size_t sig_len, const DSA *dsa) ***REMOVED***
  int valid;
  if (!DSA_check_signature(&valid, digest, digest_len, sig, sig_len, dsa)) ***REMOVED***
    return -1;
  ***REMOVED***
  return valid;
***REMOVED***

int DSA_check_signature(int *out_valid, const uint8_t *digest,
                        size_t digest_len, const uint8_t *sig, size_t sig_len,
                        const DSA *dsa) ***REMOVED***
  DSA_SIG *s = NULL;
  int ret = 0;
  uint8_t *der = NULL;

  s = DSA_SIG_new();
  if (s == NULL) ***REMOVED***
    goto err;
  ***REMOVED***

  const uint8_t *sigp = sig;
  if (d2i_DSA_SIG(&s, &sigp, sig_len) == NULL || sigp != sig + sig_len) ***REMOVED***
    goto err;
  ***REMOVED***

  /* Ensure that the signature uses DER and doesn't have trailing garbage. */
  int der_len = i2d_DSA_SIG(s, &der);
  if (der_len < 0 || (size_t)der_len != sig_len ||
      OPENSSL_memcmp(sig, der, sig_len)) ***REMOVED***
    goto err;
  ***REMOVED***

  ret = DSA_do_check_signature(out_valid, digest, digest_len, s, dsa);

err:
  OPENSSL_free(der);
  DSA_SIG_free(s);
  return ret;
***REMOVED***

/* der_len_len returns the number of bytes needed to represent a length of |len|
 * in DER. */
static size_t der_len_len(size_t len) ***REMOVED***
  if (len < 0x80) ***REMOVED***
    return 1;
  ***REMOVED***
  size_t ret = 1;
  while (len > 0) ***REMOVED***
    ret++;
    len >>= 8;
  ***REMOVED***
  return ret;
***REMOVED***

int DSA_size(const DSA *dsa) ***REMOVED***
  size_t order_len = BN_num_bytes(dsa->q);
  /* Compute the maximum length of an |order_len| byte integer. Defensively
   * assume that the leading 0x00 is included. */
  size_t integer_len = 1 /* tag */ + der_len_len(order_len + 1) + 1 + order_len;
  if (integer_len < order_len) ***REMOVED***
    return 0;
  ***REMOVED***
  /* A DSA signature is two INTEGERs. */
  size_t value_len = 2 * integer_len;
  if (value_len < integer_len) ***REMOVED***
    return 0;
  ***REMOVED***
  /* Add the header. */
  size_t ret = 1 /* tag */ + der_len_len(value_len) + value_len;
  if (ret < value_len) ***REMOVED***
    return 0;
  ***REMOVED***
  return ret;
***REMOVED***

int DSA_sign_setup(const DSA *dsa, BN_CTX *ctx_in, BIGNUM **out_kinv,
                   BIGNUM **out_r) ***REMOVED***
  BN_CTX *ctx;
  BIGNUM k, kq, *kinv = NULL, *r = NULL;
  int ret = 0;

  if (!dsa->p || !dsa->q || !dsa->g) ***REMOVED***
    OPENSSL_PUT_ERROR(DSA, DSA_R_MISSING_PARAMETERS);
    return 0;
  ***REMOVED***

  BN_init(&k);
  BN_init(&kq);

  ctx = ctx_in;
  if (ctx == NULL) ***REMOVED***
    ctx = BN_CTX_new();
    if (ctx == NULL) ***REMOVED***
      goto err;
    ***REMOVED***
  ***REMOVED***

  r = BN_new();
  if (r == NULL) ***REMOVED***
    goto err;
  ***REMOVED***

  /* Get random k */
  if (!BN_rand_range_ex(&k, 1, dsa->q)) ***REMOVED***
    goto err;
  ***REMOVED***

  if (!BN_MONT_CTX_set_locked((BN_MONT_CTX **)&dsa->method_mont_p,
                              (CRYPTO_MUTEX *)&dsa->method_mont_lock, dsa->p,
                              ctx) ||
      !BN_MONT_CTX_set_locked((BN_MONT_CTX **)&dsa->method_mont_q,
                              (CRYPTO_MUTEX *)&dsa->method_mont_lock, dsa->q,
                              ctx)) ***REMOVED***
    goto err;
  ***REMOVED***

  /* Compute r = (g^k mod p) mod q */
  if (!BN_copy(&kq, &k)) ***REMOVED***
    goto err;
  ***REMOVED***

  /* We do not want timing information to leak the length of k,
   * so we compute g^k using an equivalent exponent of fixed length.
   *
   * (This is a kludge that we need because the BN_mod_exp_mont()
   * does not let us specify the desired timing behaviour.) */

  if (!BN_add(&kq, &kq, dsa->q)) ***REMOVED***
    goto err;
  ***REMOVED***
  if (BN_num_bits(&kq) <= BN_num_bits(dsa->q) && !BN_add(&kq, &kq, dsa->q)) ***REMOVED***
    goto err;
  ***REMOVED***

  if (!BN_mod_exp_mont_consttime(r, dsa->g, &kq, dsa->p, ctx,
                                 dsa->method_mont_p)) ***REMOVED***
    goto err;
  ***REMOVED***
  if (!BN_mod(r, r, dsa->q, ctx)) ***REMOVED***
    goto err;
  ***REMOVED***

  /* Compute part of 's = inv(k) (m + xr) mod q' using Fermat's Little
   * Theorem. */
  kinv = BN_new();
  if (kinv == NULL ||
      !bn_mod_inverse_prime(kinv, &k, dsa->q, ctx, dsa->method_mont_q)) ***REMOVED***
    goto err;
  ***REMOVED***

  BN_clear_free(*out_kinv);
  *out_kinv = kinv;
  kinv = NULL;
  BN_clear_free(*out_r);
  *out_r = r;
  ret = 1;

err:
  if (!ret) ***REMOVED***
    OPENSSL_PUT_ERROR(DSA, ERR_R_BN_LIB);
    if (r != NULL) ***REMOVED***
      BN_clear_free(r);
    ***REMOVED***
  ***REMOVED***

  if (ctx_in == NULL) ***REMOVED***
    BN_CTX_free(ctx);
  ***REMOVED***
  BN_clear_free(&k);
  BN_clear_free(&kq);
  BN_clear_free(kinv);
  return ret;
***REMOVED***

int DSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_unused *unused,
                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func) ***REMOVED***
  int index;
  if (!CRYPTO_get_ex_new_index(&g_ex_data_class, &index, argl, argp, dup_func,
                               free_func)) ***REMOVED***
    return -1;
  ***REMOVED***
  return index;
***REMOVED***

int DSA_set_ex_data(DSA *d, int idx, void *arg) ***REMOVED***
  return CRYPTO_set_ex_data(&d->ex_data, idx, arg);
***REMOVED***

void *DSA_get_ex_data(const DSA *d, int idx) ***REMOVED***
  return CRYPTO_get_ex_data(&d->ex_data, idx);
***REMOVED***

DH *DSA_dup_DH(const DSA *r) ***REMOVED***
  DH *ret = NULL;

  if (r == NULL) ***REMOVED***
    goto err;
  ***REMOVED***
  ret = DH_new();
  if (ret == NULL) ***REMOVED***
    goto err;
  ***REMOVED***
  if (r->q != NULL) ***REMOVED***
    ret->priv_length = BN_num_bits(r->q);
    if ((ret->q = BN_dup(r->q)) == NULL) ***REMOVED***
      goto err;
    ***REMOVED***
  ***REMOVED***
  if ((r->p != NULL && (ret->p = BN_dup(r->p)) == NULL) ||
      (r->g != NULL && (ret->g = BN_dup(r->g)) == NULL) ||
      (r->pub_key != NULL && (ret->pub_key = BN_dup(r->pub_key)) == NULL) ||
      (r->priv_key != NULL && (ret->priv_key = BN_dup(r->priv_key)) == NULL)) ***REMOVED***
      goto err;
  ***REMOVED***

  return ret;

err:
  DH_free(ret);
  return NULL;
***REMOVED***
