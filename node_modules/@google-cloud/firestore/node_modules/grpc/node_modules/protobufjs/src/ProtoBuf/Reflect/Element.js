/**
 * Constructs a new Element implementation that checks and converts values for a
 * particular field type, as appropriate.
 *
 * An Element represents a single value: either the value of a singular field,
 * or a value contained in one entry of a repeated field or map field. This
 * class does not implement these higher-level concepts; it only encapsulates
 * the low-level typechecking and conversion.
 *
 * @exports ProtoBuf.Reflect.Element
 * @param ***REMOVED******REMOVED***name: string, wireType: number***REMOVED******REMOVED*** type Resolved data type
 * @param ***REMOVED***ProtoBuf.Reflect.T|null***REMOVED*** resolvedType Resolved type, if relevant
 * (e.g. submessage field).
 * @param ***REMOVED***boolean***REMOVED*** isMapKey Is this element a Map key? The value will be
 * converted to string form if so.
 * @param ***REMOVED***string***REMOVED*** syntax Syntax level of defining message type, e.g.,
 * proto2 or proto3.
 * @param ***REMOVED***string***REMOVED*** name Name of the field containing this element (for error
 * messages)
 * @constructor
 */
var Element = function(type, resolvedType, isMapKey, syntax, name) ***REMOVED***

    /**
     * Element type, as a string (e.g., int32).
     * @type ***REMOVED******REMOVED***name: string, wireType: number***REMOVED******REMOVED***
     */
    this.type = type;

    /**
     * Element type reference to submessage or enum definition, if needed.
     * @type ***REMOVED***ProtoBuf.Reflect.T|null***REMOVED***
     */
    this.resolvedType = resolvedType;

    /**
     * Element is a map key.
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.isMapKey = isMapKey;

    /**
     * Syntax level of defining message type, e.g., proto2 or proto3.
     * @type ***REMOVED***string***REMOVED***
     */
    this.syntax = syntax;

    /**
     * Name of the field containing this element (for error messages)
     * @type ***REMOVED***string***REMOVED***
     */
    this.name = name;

    if (isMapKey && ProtoBuf.MAP_KEY_TYPES.indexOf(type) < 0)
        throw Error("Invalid map key type: " + type.name);
***REMOVED***;

var ElementPrototype = Element.prototype;

/**
 * Obtains a (new) default value for the specified type.
 * @param type ***REMOVED***string|***REMOVED***name: string, wireType: number***REMOVED******REMOVED*** Field type
 * @returns ***REMOVED*******REMOVED*** Default value
 * @inner
 */
function mkDefault(type) ***REMOVED***
    if (typeof type === 'string')
        type = ProtoBuf.TYPES[type];
    if (typeof type.defaultValue === 'undefined')
        throw Error("default value for type "+type.name+" is not supported");
    if (type == ProtoBuf.TYPES["bytes"])
        return new ByteBuffer(0);
    return type.defaultValue;
***REMOVED***

/**
 * Returns the default value for this field in proto3.
 * @function
 * @param type ***REMOVED***string|***REMOVED***name: string, wireType: number***REMOVED******REMOVED*** the field type
 * @returns ***REMOVED*******REMOVED*** Default value
 */
Element.defaultFieldValue = mkDefault;

/**
 * Makes a Long from a value.
 * @param ***REMOVED******REMOVED***low: number, high: number, unsigned: boolean***REMOVED***|string|number***REMOVED*** value Value
 * @param ***REMOVED***boolean=***REMOVED*** unsigned Whether unsigned or not, defaults to reuse it from Long-like objects or to signed for
 *  strings and numbers
 * @returns ***REMOVED***!Long***REMOVED***
 * @throws ***REMOVED***Error***REMOVED*** If the value cannot be converted to a Long
 * @inner
 */
function mkLong(value, unsigned) ***REMOVED***
    if (value && typeof value.low === 'number' && typeof value.high === 'number' && typeof value.unsigned === 'boolean'
        && value.low === value.low && value.high === value.high)
        return new ProtoBuf.Long(value.low, value.high, typeof unsigned === 'undefined' ? value.unsigned : unsigned);
    if (typeof value === 'string')
        return ProtoBuf.Long.fromString(value, unsigned || false, 10);
    if (typeof value === 'number')
        return ProtoBuf.Long.fromNumber(value, unsigned || false);
    throw Error("not convertible to Long");
***REMOVED***

ElementPrototype.toString = function() ***REMOVED***
    return (this.name || '') + (this.isMapKey ? 'map' : 'value') + ' element';
***REMOVED***

/**
 * Checks if the given value can be set for an element of this type (singular
 * field or one element of a repeated field or map).
 * @param ***REMOVED*******REMOVED*** value Value to check
 * @return ***REMOVED*******REMOVED*** Verified, maybe adjusted, value
 * @throws ***REMOVED***Error***REMOVED*** If the value cannot be verified for this element slot
 * @expose
 */
ElementPrototype.verifyValue = function(value) ***REMOVED***
    var self = this;
    function fail(val, msg) ***REMOVED***
        throw Error("Illegal value for "+self.toString(true)+" of type "+self.type.name+": "+val+" ("+msg+")");
    ***REMOVED***
    switch (this.type) ***REMOVED***
        // Signed 32bit
        case ProtoBuf.TYPES["int32"]:
        case ProtoBuf.TYPES["sint32"]:
        case ProtoBuf.TYPES["sfixed32"]:
            // Account for !NaN: value === value
            if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                fail(typeof value, "not an integer");
            return value > 4294967295 ? value | 0 : value;

        // Unsigned 32bit
        case ProtoBuf.TYPES["uint32"]:
        case ProtoBuf.TYPES["fixed32"]:
            if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                fail(typeof value, "not an integer");
            return value < 0 ? value >>> 0 : value;

        // Signed 64bit
        case ProtoBuf.TYPES["int64"]:
        case ProtoBuf.TYPES["sint64"]:
        case ProtoBuf.TYPES["sfixed64"]: ***REMOVED***
            if (ProtoBuf.Long)
                try ***REMOVED***
                    return mkLong(value, false);
                ***REMOVED*** catch (e) ***REMOVED***
                    fail(typeof value, e.message);
                ***REMOVED***
            else
                fail(typeof value, "requires Long.js");
        ***REMOVED***

        // Unsigned 64bit
        case ProtoBuf.TYPES["uint64"]:
        case ProtoBuf.TYPES["fixed64"]: ***REMOVED***
            if (ProtoBuf.Long)
                try ***REMOVED***
                    return mkLong(value, true);
                ***REMOVED*** catch (e) ***REMOVED***
                    fail(typeof value, e.message);
                ***REMOVED***
            else
                fail(typeof value, "requires Long.js");
        ***REMOVED***

        // Bool
        case ProtoBuf.TYPES["bool"]:
            if (typeof value !== 'boolean')
                fail(typeof value, "not a boolean");
            return value;

        // Float
        case ProtoBuf.TYPES["float"]:
        case ProtoBuf.TYPES["double"]:
            if (typeof value !== 'number')
                fail(typeof value, "not a number");
            return value;

        // Length-delimited string
        case ProtoBuf.TYPES["string"]:
            if (typeof value !== 'string' && !(value && value instanceof String))
                fail(typeof value, "not a string");
            return ""+value; // Convert String object to string

        // Length-delimited bytes
        case ProtoBuf.TYPES["bytes"]:
            if (ByteBuffer.isByteBuffer(value))
                return value;
            return ByteBuffer.wrap(value, "base64");

        // Constant enum value
        case ProtoBuf.TYPES["enum"]: ***REMOVED***
            var values = this.resolvedType.getChildren(ProtoBuf.Reflect.Enum.Value);
            for (i=0; i<values.length; i++)
                if (values[i].name == value)
                    return values[i].id;
                else if (values[i].id == value)
                    return values[i].id;

            if (this.syntax === 'proto3') ***REMOVED***
                // proto3: just make sure it's an integer.
                if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                    fail(typeof value, "not an integer");
                if (value > 4294967295 || value < 0)
                    fail(typeof value, "not in range for uint32")
                return value;
            ***REMOVED*** else ***REMOVED***
                // proto2 requires enum values to be valid.
                fail(value, "not a valid enum value");
            ***REMOVED***
        ***REMOVED***
        // Embedded message
        case ProtoBuf.TYPES["group"]:
        case ProtoBuf.TYPES["message"]: ***REMOVED***
            if (!value || typeof value !== 'object')
                fail(typeof value, "object expected");
            if (value instanceof this.resolvedType.clazz)
                return value;
            if (value instanceof ProtoBuf.Builder.Message) ***REMOVED***
                // Mismatched type: Convert to object (see: https://github.com/dcodeIO/ProtoBuf.js/issues/180)
                var obj = ***REMOVED******REMOVED***;
                for (var i in value)
                    if (value.hasOwnProperty(i))
                        obj[i] = value[i];
                value = obj;
            ***REMOVED***
            // Else let's try to construct one from a key-value object
            return new (this.resolvedType.clazz)(value); // May throw for a hundred of reasons
        ***REMOVED***
    ***REMOVED***

    // We should never end here
    throw Error("[INTERNAL] Illegal value for "+this.toString(true)+": "+value+" (undefined type "+this.type+")");
***REMOVED***;

/**
 * Calculates the byte length of an element on the wire.
 * @param ***REMOVED***number***REMOVED*** id Field number
 * @param ***REMOVED*******REMOVED*** value Field value
 * @returns ***REMOVED***number***REMOVED*** Byte length
 * @throws ***REMOVED***Error***REMOVED*** If the value cannot be calculated
 * @expose
 */
ElementPrototype.calculateLength = function(id, value) ***REMOVED***
    if (value === null) return 0; // Nothing to encode
    // Tag has already been written
    var n;
    switch (this.type) ***REMOVED***
        case ProtoBuf.TYPES["int32"]:
            return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);
        case ProtoBuf.TYPES["uint32"]:
            return ByteBuffer.calculateVarint32(value);
        case ProtoBuf.TYPES["sint32"]:
            return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));
        case ProtoBuf.TYPES["fixed32"]:
        case ProtoBuf.TYPES["sfixed32"]:
        case ProtoBuf.TYPES["float"]:
            return 4;
        case ProtoBuf.TYPES["int64"]:
        case ProtoBuf.TYPES["uint64"]:
            return ByteBuffer.calculateVarint64(value);
        case ProtoBuf.TYPES["sint64"]:
            return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));
        case ProtoBuf.TYPES["fixed64"]:
        case ProtoBuf.TYPES["sfixed64"]:
            return 8;
        case ProtoBuf.TYPES["bool"]:
            return 1;
        case ProtoBuf.TYPES["enum"]:
            return ByteBuffer.calculateVarint32(value);
        case ProtoBuf.TYPES["double"]:
            return 8;
        case ProtoBuf.TYPES["string"]:
            n = ByteBuffer.calculateUTF8Bytes(value);
            return ByteBuffer.calculateVarint32(n) + n;
        case ProtoBuf.TYPES["bytes"]:
            if (value.remaining() < 0)
                throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
            return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();
        case ProtoBuf.TYPES["message"]:
            n = this.resolvedType.calculate(value);
            return ByteBuffer.calculateVarint32(n) + n;
        case ProtoBuf.TYPES["group"]:
            n = this.resolvedType.calculate(value);
            return n + ByteBuffer.calculateVarint32((id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
    ***REMOVED***
    // We should never end here
    throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
***REMOVED***;

/**
 * Encodes a value to the specified buffer. Does not encode the key.
 * @param ***REMOVED***number***REMOVED*** id Field number
 * @param ***REMOVED*******REMOVED*** value Field value
 * @param ***REMOVED***ByteBuffer***REMOVED*** buffer ByteBuffer to encode to
 * @return ***REMOVED***ByteBuffer***REMOVED*** The ByteBuffer for chaining
 * @throws ***REMOVED***Error***REMOVED*** If the value cannot be encoded
 * @expose
 */
ElementPrototype.encodeValue = function(id, value, buffer) ***REMOVED***
    if (value === null) return buffer; // Nothing to encode
    // Tag has already been written

    switch (this.type) ***REMOVED***
        // 32bit signed varint
        case ProtoBuf.TYPES["int32"]:
            // "If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes
            // long â€“ it is, effectively, treated like a very large unsigned integer." (see #122)
            if (value < 0)
                buffer.writeVarint64(value);
            else
                buffer.writeVarint32(value);
            break;

        // 32bit unsigned varint
        case ProtoBuf.TYPES["uint32"]:
            buffer.writeVarint32(value);
            break;

        // 32bit varint zig-zag
        case ProtoBuf.TYPES["sint32"]:
            buffer.writeVarint32ZigZag(value);
            break;

        // Fixed unsigned 32bit
        case ProtoBuf.TYPES["fixed32"]:
            buffer.writeUint32(value);
            break;

        // Fixed signed 32bit
        case ProtoBuf.TYPES["sfixed32"]:
            buffer.writeInt32(value);
            break;

        // 64bit varint as-is
        case ProtoBuf.TYPES["int64"]:
        case ProtoBuf.TYPES["uint64"]:
            buffer.writeVarint64(value); // throws
            break;

        // 64bit varint zig-zag
        case ProtoBuf.TYPES["sint64"]:
            buffer.writeVarint64ZigZag(value); // throws
            break;

        // Fixed unsigned 64bit
        case ProtoBuf.TYPES["fixed64"]:
            buffer.writeUint64(value); // throws
            break;

        // Fixed signed 64bit
        case ProtoBuf.TYPES["sfixed64"]:
            buffer.writeInt64(value); // throws
            break;

        // Bool
        case ProtoBuf.TYPES["bool"]:
            if (typeof value === 'string')
                buffer.writeVarint32(value.toLowerCase() === 'false' ? 0 : !!value);
            else
                buffer.writeVarint32(value ? 1 : 0);
            break;

        // Constant enum value
        case ProtoBuf.TYPES["enum"]:
            buffer.writeVarint32(value);
            break;

        // 32bit float
        case ProtoBuf.TYPES["float"]:
            buffer.writeFloat32(value);
            break;

        // 64bit float
        case ProtoBuf.TYPES["double"]:
            buffer.writeFloat64(value);
            break;

        // Length-delimited string
        case ProtoBuf.TYPES["string"]:
            buffer.writeVString(value);
            break;

        // Length-delimited bytes
        case ProtoBuf.TYPES["bytes"]:
            if (value.remaining() < 0)
                throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
            var prevOffset = value.offset;
            buffer.writeVarint32(value.remaining());
            buffer.append(value);
            value.offset = prevOffset;
            break;

        // Embedded message
        case ProtoBuf.TYPES["message"]:
            var bb = new ByteBuffer().LE();
            this.resolvedType.encode(value, bb);
            buffer.writeVarint32(bb.offset);
            buffer.append(bb.flip());
            break;

        // Legacy group
        case ProtoBuf.TYPES["group"]:
            this.resolvedType.encode(value, buffer);
            buffer.writeVarint32((id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
            break;

        default:
            // We should never end here
            throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
    ***REMOVED***
    return buffer;
***REMOVED***;

/**
 * Decode one element value from the specified buffer.
 * @param ***REMOVED***ByteBuffer***REMOVED*** buffer ByteBuffer to decode from
 * @param ***REMOVED***number***REMOVED*** wireType The field wire type
 * @param ***REMOVED***number***REMOVED*** id The field number
 * @return ***REMOVED*******REMOVED*** Decoded value
 * @throws ***REMOVED***Error***REMOVED*** If the field cannot be decoded
 * @expose
 */
ElementPrototype.decode = function(buffer, wireType, id) ***REMOVED***
    if (wireType != this.type.wireType)
        throw Error("Unexpected wire type for element");

    var value, nBytes;
    switch (this.type) ***REMOVED***
        // 32bit signed varint
        case ProtoBuf.TYPES["int32"]:
            return buffer.readVarint32() | 0;

        // 32bit unsigned varint
        case ProtoBuf.TYPES["uint32"]:
            return buffer.readVarint32() >>> 0;

        // 32bit signed varint zig-zag
        case ProtoBuf.TYPES["sint32"]:
            return buffer.readVarint32ZigZag() | 0;

        // Fixed 32bit unsigned
        case ProtoBuf.TYPES["fixed32"]:
            return buffer.readUint32() >>> 0;

        case ProtoBuf.TYPES["sfixed32"]:
            return buffer.readInt32() | 0;

        // 64bit signed varint
        case ProtoBuf.TYPES["int64"]:
            return buffer.readVarint64();

        // 64bit unsigned varint
        case ProtoBuf.TYPES["uint64"]:
            return buffer.readVarint64().toUnsigned();

        // 64bit signed varint zig-zag
        case ProtoBuf.TYPES["sint64"]:
            return buffer.readVarint64ZigZag();

        // Fixed 64bit unsigned
        case ProtoBuf.TYPES["fixed64"]:
            return buffer.readUint64();

        // Fixed 64bit signed
        case ProtoBuf.TYPES["sfixed64"]:
            return buffer.readInt64();

        // Bool varint
        case ProtoBuf.TYPES["bool"]:
            return !!buffer.readVarint32();

        // Constant enum value (varint)
        case ProtoBuf.TYPES["enum"]:
            // The following Builder.Message#set will already throw
            return buffer.readVarint32();

        // 32bit float
        case ProtoBuf.TYPES["float"]:
            return buffer.readFloat();

        // 64bit float
        case ProtoBuf.TYPES["double"]:
            return buffer.readDouble();

        // Length-delimited string
        case ProtoBuf.TYPES["string"]:
            return buffer.readVString();

        // Length-delimited bytes
        case ProtoBuf.TYPES["bytes"]: ***REMOVED***
            nBytes = buffer.readVarint32();
            if (buffer.remaining() < nBytes)
                throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());
            value = buffer.clone(); // Offset already set
            value.limit = value.offset+nBytes;
            buffer.offset += nBytes;
            return value;
        ***REMOVED***

        // Length-delimited embedded message
        case ProtoBuf.TYPES["message"]: ***REMOVED***
            nBytes = buffer.readVarint32();
            return this.resolvedType.decode(buffer, nBytes);
        ***REMOVED***

        // Legacy group
        case ProtoBuf.TYPES["group"]:
            return this.resolvedType.decode(buffer, -1, id);
    ***REMOVED***

    // We should never end here
    throw Error("[INTERNAL] Illegal decode type");
***REMOVED***;

/**
 * Converts a value from a string to the canonical element type.
 *
 * Legal only when isMapKey is true.
 *
 * @param ***REMOVED***string***REMOVED*** str The string value
 * @returns ***REMOVED*******REMOVED*** The value
 */
ElementPrototype.valueFromString = function(str) ***REMOVED***
    if (!this.isMapKey) ***REMOVED***
        throw Error("valueFromString() called on non-map-key element");
    ***REMOVED***

    switch (this.type) ***REMOVED***
        case ProtoBuf.TYPES["int32"]:
        case ProtoBuf.TYPES["sint32"]:
        case ProtoBuf.TYPES["sfixed32"]:
        case ProtoBuf.TYPES["uint32"]:
        case ProtoBuf.TYPES["fixed32"]:
            return this.verifyValue(parseInt(str));

        case ProtoBuf.TYPES["int64"]:
        case ProtoBuf.TYPES["sint64"]:
        case ProtoBuf.TYPES["sfixed64"]:
        case ProtoBuf.TYPES["uint64"]:
        case ProtoBuf.TYPES["fixed64"]:
              // Long-based fields support conversions from string already.
              return this.verifyValue(str);

        case ProtoBuf.TYPES["bool"]:
              return str === "true";

        case ProtoBuf.TYPES["string"]:
              return this.verifyValue(str);

        case ProtoBuf.TYPES["bytes"]:
              return ByteBuffer.fromBinary(str);
    ***REMOVED***
***REMOVED***;

/**
 * Converts a value from the canonical element type to a string.
 *
 * It should be the case that `valueFromString(valueToString(val))` returns
 * a value equivalent to `verifyValue(val)` for every legal value of `val`
 * according to this element type.
 *
 * This may be used when the element must be stored or used as a string,
 * e.g., as a map key on an Object.
 *
 * Legal only when isMapKey is true.
 *
 * @param ***REMOVED*******REMOVED*** val The value
 * @returns ***REMOVED***string***REMOVED*** The string form of the value.
 */
ElementPrototype.valueToString = function(value) ***REMOVED***
    if (!this.isMapKey) ***REMOVED***
        throw Error("valueToString() called on non-map-key element");
    ***REMOVED***

    if (this.type === ProtoBuf.TYPES["bytes"]) ***REMOVED***
        return value.toString("binary");
    ***REMOVED*** else ***REMOVED***
        return value.toString();
    ***REMOVED***
***REMOVED***;
