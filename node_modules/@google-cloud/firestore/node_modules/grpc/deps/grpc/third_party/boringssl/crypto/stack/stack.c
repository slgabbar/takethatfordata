/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.] */

#include <openssl/stack.h>

#include <string.h>

#include <openssl/mem.h>

#include "../internal.h"


/* kMinSize is the number of pointers that will be initially allocated in a new
 * stack. */
static const size_t kMinSize = 4;

_STACK *sk_new(stack_cmp_func comp) ***REMOVED***
  _STACK *ret;

  ret = OPENSSL_malloc(sizeof(_STACK));
  if (ret == NULL) ***REMOVED***
    goto err;
  ***REMOVED***
  OPENSSL_memset(ret, 0, sizeof(_STACK));

  ret->data = OPENSSL_malloc(sizeof(void *) * kMinSize);
  if (ret->data == NULL) ***REMOVED***
    goto err;
  ***REMOVED***

  OPENSSL_memset(ret->data, 0, sizeof(void *) * kMinSize);

  ret->comp = comp;
  ret->num_alloc = kMinSize;

  return ret;

err:
  OPENSSL_free(ret);
  return NULL;
***REMOVED***

_STACK *sk_new_null(void) ***REMOVED*** return sk_new(NULL); ***REMOVED***

size_t sk_num(const _STACK *sk) ***REMOVED***
  if (sk == NULL) ***REMOVED***
    return 0;
  ***REMOVED***
  return sk->num;
***REMOVED***

void sk_zero(_STACK *sk) ***REMOVED***
  if (sk == NULL || sk->num == 0) ***REMOVED***
    return;
  ***REMOVED***
  OPENSSL_memset(sk->data, 0, sizeof(void*) * sk->num);
  sk->num = 0;
  sk->sorted = 0;
***REMOVED***

void *sk_value(const _STACK *sk, size_t i) ***REMOVED***
  if (!sk || i >= sk->num) ***REMOVED***
    return NULL;
  ***REMOVED***
  return sk->data[i];
***REMOVED***

void *sk_set(_STACK *sk, size_t i, void *value) ***REMOVED***
  if (!sk || i >= sk->num) ***REMOVED***
    return NULL;
  ***REMOVED***
  return sk->data[i] = value;
***REMOVED***

void sk_free(_STACK *sk) ***REMOVED***
  if (sk == NULL) ***REMOVED***
    return;
  ***REMOVED***
  OPENSSL_free(sk->data);
  OPENSSL_free(sk);
***REMOVED***

void sk_pop_free(_STACK *sk, void (*func)(void *)) ***REMOVED***
  if (sk == NULL) ***REMOVED***
    return;
  ***REMOVED***

  for (size_t i = 0; i < sk->num; i++) ***REMOVED***
    if (sk->data[i] != NULL) ***REMOVED***
      func(sk->data[i]);
    ***REMOVED***
  ***REMOVED***
  sk_free(sk);
***REMOVED***

size_t sk_insert(_STACK *sk, void *p, size_t where) ***REMOVED***
  if (sk == NULL) ***REMOVED***
    return 0;
  ***REMOVED***

  if (sk->num_alloc <= sk->num + 1) ***REMOVED***
    /* Attempt to double the size of the array. */
    size_t new_alloc = sk->num_alloc << 1;
    size_t alloc_size = new_alloc * sizeof(void *);
    void **data;

    /* If the doubling overflowed, try to increment. */
    if (new_alloc < sk->num_alloc || alloc_size / sizeof(void *) != new_alloc) ***REMOVED***
      new_alloc = sk->num_alloc + 1;
      alloc_size = new_alloc * sizeof(void *);
    ***REMOVED***

    /* If the increment also overflowed, fail. */
    if (new_alloc < sk->num_alloc || alloc_size / sizeof(void *) != new_alloc) ***REMOVED***
      return 0;
    ***REMOVED***

    data = OPENSSL_realloc(sk->data, alloc_size);
    if (data == NULL) ***REMOVED***
      return 0;
    ***REMOVED***

    sk->data = data;
    sk->num_alloc = new_alloc;
  ***REMOVED***

  if (where >= sk->num) ***REMOVED***
    sk->data[sk->num] = p;
  ***REMOVED*** else ***REMOVED***
    OPENSSL_memmove(&sk->data[where + 1], &sk->data[where],
                    sizeof(void *) * (sk->num - where));
    sk->data[where] = p;
  ***REMOVED***

  sk->num++;
  sk->sorted = 0;

  return sk->num;
***REMOVED***

void *sk_delete(_STACK *sk, size_t where) ***REMOVED***
  void *ret;

  if (!sk || where >= sk->num) ***REMOVED***
    return NULL;
  ***REMOVED***

  ret = sk->data[where];

  if (where != sk->num - 1) ***REMOVED***
    OPENSSL_memmove(&sk->data[where], &sk->data[where + 1],
            sizeof(void *) * (sk->num - where - 1));
  ***REMOVED***

  sk->num--;
  return ret;
***REMOVED***

void *sk_delete_ptr(_STACK *sk, void *p) ***REMOVED***
  if (sk == NULL) ***REMOVED***
    return NULL;
  ***REMOVED***

  for (size_t i = 0; i < sk->num; i++) ***REMOVED***
    if (sk->data[i] == p) ***REMOVED***
      return sk_delete(sk, i);
    ***REMOVED***
  ***REMOVED***

  return NULL;
***REMOVED***

int sk_find(_STACK *sk, size_t *out_index, void *p) ***REMOVED***
  if (sk == NULL) ***REMOVED***
    return 0;
  ***REMOVED***

  if (sk->comp == NULL) ***REMOVED***
    /* Use pointer equality when no comparison function has been set. */
    for (size_t i = 0; i < sk->num; i++) ***REMOVED***
      if (sk->data[i] == p) ***REMOVED***
        if (out_index) ***REMOVED***
          *out_index = i;
        ***REMOVED***
        return 1;
      ***REMOVED***
    ***REMOVED***
    return 0;
  ***REMOVED***

  if (p == NULL) ***REMOVED***
    return 0;
  ***REMOVED***

  sk_sort(sk);

  /* sk->comp is a function that takes pointers to pointers to elements, but
   * qsort and bsearch take a comparison function that just takes pointers to
   * elements. However, since we're passing an array of pointers to
   * qsort/bsearch, we can just cast the comparison function and everything
   * works. */
  const void *const *r = bsearch(&p, sk->data, sk->num, sizeof(void *),
                                 (int (*)(const void *, const void *))sk->comp);
  if (r == NULL) ***REMOVED***
    return 0;
  ***REMOVED***
  size_t idx = ((void **)r) - sk->data;
  /* This function always returns the first result. */
  while (idx > 0 &&
         sk->comp((const void **)&p, (const void **)&sk->data[idx - 1]) == 0) ***REMOVED***
    idx--;
  ***REMOVED***
  if (out_index) ***REMOVED***
    *out_index = idx;
  ***REMOVED***
  return 1;
***REMOVED***

void *sk_shift(_STACK *sk) ***REMOVED***
  if (sk == NULL) ***REMOVED***
    return NULL;
  ***REMOVED***
  if (sk->num == 0) ***REMOVED***
    return NULL;
  ***REMOVED***
  return sk_delete(sk, 0);
***REMOVED***

size_t sk_push(_STACK *sk, void *p) ***REMOVED*** return (sk_insert(sk, p, sk->num)); ***REMOVED***

void *sk_pop(_STACK *sk) ***REMOVED***
  if (sk == NULL) ***REMOVED***
    return NULL;
  ***REMOVED***
  if (sk->num == 0) ***REMOVED***
    return NULL;
  ***REMOVED***
  return sk_delete(sk, sk->num - 1);
***REMOVED***

_STACK *sk_dup(const _STACK *sk) ***REMOVED***
  _STACK *ret;
  void **s;

  if (sk == NULL) ***REMOVED***
    return NULL;
  ***REMOVED***

  ret = sk_new(sk->comp);
  if (ret == NULL) ***REMOVED***
    goto err;
  ***REMOVED***

  s = (void **)OPENSSL_realloc(ret->data, sizeof(void *) * sk->num_alloc);
  if (s == NULL) ***REMOVED***
    goto err;
  ***REMOVED***
  ret->data = s;

  ret->num = sk->num;
  OPENSSL_memcpy(ret->data, sk->data, sizeof(void *) * sk->num);
  ret->sorted = sk->sorted;
  ret->num_alloc = sk->num_alloc;
  ret->comp = sk->comp;
  return ret;

err:
  sk_free(ret);
  return NULL;
***REMOVED***

void sk_sort(_STACK *sk) ***REMOVED***
  int (*comp_func)(const void *,const void *);

  if (sk == NULL || sk->comp == NULL || sk->sorted) ***REMOVED***
    return;
  ***REMOVED***

  /* See the comment in sk_find about this cast. */
  comp_func = (int (*)(const void *, const void *))(sk->comp);
  qsort(sk->data, sk->num, sizeof(void *), comp_func);
  sk->sorted = 1;
***REMOVED***

int sk_is_sorted(const _STACK *sk) ***REMOVED***
  if (!sk) ***REMOVED***
    return 1;
  ***REMOVED***
  return sk->sorted;
***REMOVED***

stack_cmp_func sk_set_cmp_func(_STACK *sk, stack_cmp_func comp) ***REMOVED***
  stack_cmp_func old = sk->comp;

  if (sk->comp != comp) ***REMOVED***
    sk->sorted = 0;
  ***REMOVED***
  sk->comp = comp;

  return old;
***REMOVED***

_STACK *sk_deep_copy(const _STACK *sk, void *(*copy_func)(void *),
                     void (*free_func)(void *)) ***REMOVED***
  _STACK *ret = sk_dup(sk);
  if (ret == NULL) ***REMOVED***
    return NULL;
  ***REMOVED***

  for (size_t i = 0; i < ret->num; i++) ***REMOVED***
    if (ret->data[i] == NULL) ***REMOVED***
      continue;
    ***REMOVED***
    ret->data[i] = copy_func(ret->data[i]);
    if (ret->data[i] == NULL) ***REMOVED***
      for (size_t j = 0; j < i; j++) ***REMOVED***
        if (ret->data[j] != NULL) ***REMOVED***
          free_func(ret->data[j]);
        ***REMOVED***
      ***REMOVED***
      sk_free(ret);
      return NULL;
    ***REMOVED***
  ***REMOVED***

  return ret;
***REMOVED***
