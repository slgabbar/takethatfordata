/**
 * @license
 * Copyright 2015 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

'use strict';

var _ = require('lodash');

var grpc = require('./grpc_extension');

var common = require('./common');

var Metadata = require('./metadata');

var constants = require('./constants');

var stream = require('stream');

var Readable = stream.Readable;
var Writable = stream.Writable;
var Duplex = stream.Duplex;
var util = require('util');

var EventEmitter = require('events').EventEmitter;

/**
 * Handle an error on a call by sending it as a status
 * @private
 * @param ***REMOVED***grpc.internal~Call***REMOVED*** call The call to send the error on
 * @param ***REMOVED***(Object|Error)***REMOVED*** error The error object
 */
function handleError(call, error) ***REMOVED***
  var statusMetadata = new Metadata();
  var status = ***REMOVED***
    code: constants.status.UNKNOWN,
    details: 'Unknown Error'
  ***REMOVED***;
  if (error.hasOwnProperty('message')) ***REMOVED***
    status.details = error.message;
  ***REMOVED***
  if (error.hasOwnProperty('code')) ***REMOVED***
    status.code = error.code;
    if (error.hasOwnProperty('details')) ***REMOVED***
      status.details = error.details;
    ***REMOVED***
  ***REMOVED***
  if (error.hasOwnProperty('metadata')) ***REMOVED***
    statusMetadata = error.metadata;
  ***REMOVED***
  status.metadata = statusMetadata._getCoreRepresentation();
  var error_batch = ***REMOVED******REMOVED***;
  if (!call.metadataSent) ***REMOVED***
    error_batch[grpc.opType.SEND_INITIAL_METADATA] =
        (new Metadata())._getCoreRepresentation();
  ***REMOVED***
  error_batch[grpc.opType.SEND_STATUS_FROM_SERVER] = status;
  call.startBatch(error_batch, function()***REMOVED******REMOVED***);
***REMOVED***

/**
 * Send a response to a unary or client streaming call.
 * @private
 * @param ***REMOVED***grpc.Call***REMOVED*** call The call to respond on
 * @param ***REMOVED*******REMOVED*** value The value to respond with
 * @param ***REMOVED***grpc~serialize***REMOVED*** serialize Serialization function for the
 *     response
 * @param ***REMOVED***grpc.Metadata=***REMOVED*** metadata Optional trailing metadata to send with
 *     status
 * @param ***REMOVED***number=***REMOVED*** [flags=0] Flags for modifying how the message is sent.
 */
function sendUnaryResponse(call, value, serialize, metadata, flags) ***REMOVED***
  var end_batch = ***REMOVED******REMOVED***;
  var statusMetadata = new Metadata();
  var status = ***REMOVED***
    code: constants.status.OK,
    details: 'OK'
  ***REMOVED***;
  if (metadata) ***REMOVED***
    statusMetadata = metadata;
  ***REMOVED***
  var message;
  try ***REMOVED***
    message = serialize(value);
  ***REMOVED*** catch (e) ***REMOVED***
    e.code = constants.status.INTERNAL;
    handleError(call, e);
    return;
  ***REMOVED***
  status.metadata = statusMetadata._getCoreRepresentation();
  if (!call.metadataSent) ***REMOVED***
    end_batch[grpc.opType.SEND_INITIAL_METADATA] =
        (new Metadata())._getCoreRepresentation();
    call.metadataSent = true;
  ***REMOVED***
  message.grpcWriteFlags = flags;
  end_batch[grpc.opType.SEND_MESSAGE] = message;
  end_batch[grpc.opType.SEND_STATUS_FROM_SERVER] = status;
  call.startBatch(end_batch, function ()***REMOVED******REMOVED***);
***REMOVED***

/**
 * Initialize a writable stream. This is used for both the writable and duplex
 * stream constructors.
 * @private
 * @param ***REMOVED***Writable***REMOVED*** stream The stream to set up
 * @param ***REMOVED***function(*):Buffer=***REMOVED*** Serialization function for responses
 */
function setUpWritable(stream, serialize) ***REMOVED***
  stream.finished = false;
  stream.status = ***REMOVED***
    code : constants.status.OK,
    details : 'OK',
    metadata : new Metadata()
  ***REMOVED***;
  stream.serialize = common.wrapIgnoreNull(serialize);
  function sendStatus() ***REMOVED***
    var batch = ***REMOVED******REMOVED***;
    if (!stream.call.metadataSent) ***REMOVED***
      stream.call.metadataSent = true;
      batch[grpc.opType.SEND_INITIAL_METADATA] =
          (new Metadata())._getCoreRepresentation();
    ***REMOVED***

    if (stream.status.metadata) ***REMOVED***
      stream.status.metadata = stream.status.metadata._getCoreRepresentation();
    ***REMOVED***
    batch[grpc.opType.SEND_STATUS_FROM_SERVER] = stream.status;
    stream.call.startBatch(batch, function()***REMOVED******REMOVED***);
  ***REMOVED***
  stream.on('finish', sendStatus);
  /**
   * Set the pending status to a given error status. If the error does not have
   * code or details properties, the code will be set to grpc.status.UNKNOWN
   * and the details will be set to 'Unknown Error'.
   * @param ***REMOVED***Error***REMOVED*** err The error object
   */
  function setStatus(err) ***REMOVED***
    var code = constants.status.UNKNOWN;
    var details = 'Unknown Error';
    var metadata = new Metadata();
    if (err.hasOwnProperty('message')) ***REMOVED***
      details = err.message;
    ***REMOVED***
    if (err.hasOwnProperty('code')) ***REMOVED***
      code = err.code;
      if (err.hasOwnProperty('details')) ***REMOVED***
        details = err.details;
      ***REMOVED***
    ***REMOVED***
    if (err.hasOwnProperty('metadata')) ***REMOVED***
      metadata = err.metadata;
    ***REMOVED***
    stream.status = ***REMOVED***code: code, details: details, metadata: metadata***REMOVED***;
  ***REMOVED***
  /**
   * Terminate the call. This includes indicating that reads are done, draining
   * all pending writes, and sending the given error as a status
   * @param ***REMOVED***Error***REMOVED*** err The error object
   * @this GrpcServerStream
   */
  function terminateCall(err) ***REMOVED***
    // Drain readable data
    setStatus(err);
    stream.end();
  ***REMOVED***
  stream.on('error', terminateCall);
  /**
   * Override of Writable#end method that allows for sending metadata with a
   * success status.
   * @param ***REMOVED***Metadata=***REMOVED*** metadata Metadata to send with the status
   */
  stream.end = function(metadata) ***REMOVED***
    if (metadata) ***REMOVED***
      stream.status.metadata = metadata;
    ***REMOVED***
    Writable.prototype.end.call(this);
  ***REMOVED***;
***REMOVED***

/**
 * Initialize a readable stream. This is used for both the readable and duplex
 * stream constructors.
 * @private
 * @param ***REMOVED***Readable***REMOVED*** stream The stream to initialize
 * @param ***REMOVED***grpc~deserialize***REMOVED*** deserialize Deserialization function for
 *     incoming data.
 */
function setUpReadable(stream, deserialize) ***REMOVED***
  stream.deserialize = common.wrapIgnoreNull(deserialize);
  stream.finished = false;
  stream.reading = false;

  stream.terminate = function() ***REMOVED***
    stream.finished = true;
    stream.on('data', function() ***REMOVED******REMOVED***);
  ***REMOVED***;

  stream.on('cancelled', function() ***REMOVED***
    stream.terminate();
  ***REMOVED***);
***REMOVED***

/**
 * Emitted when the call has been cancelled. After this has been emitted, the
 * call's `cancelled` property will be set to `true`.
 * @event grpc~ServerUnaryCall~cancelled
 */

util.inherits(ServerUnaryCall, EventEmitter);

/**
 * An EventEmitter. Used for unary calls.
 * @constructor grpc~ServerUnaryCall
 * @extends external:EventEmitter
 * @param ***REMOVED***grpc.internal~Call***REMOVED*** call The call object associated with the request
 * @param ***REMOVED***grpc.Metadata***REMOVED*** metadata The request metadata from the client
 */
function ServerUnaryCall(call, metadata) ***REMOVED***
  EventEmitter.call(this);
  this.call = call;
  /**
   * Indicates if the call has been cancelled
   * @member ***REMOVED***boolean***REMOVED*** grpc~ServerUnaryCall#cancelled
   */
  this.cancelled = false;
  /**
   * The request metadata from the client
   * @member ***REMOVED***grpc.Metadata***REMOVED*** grpc~ServerUnaryCall#metadata
   */
  this.metadata = metadata;
  /**
   * The request message from the client
   * @member ***REMOVED*******REMOVED*** grpc~ServerUnaryCall#request
   */
  this.request = undefined;
***REMOVED***

/**
 * Emitted when the call has been cancelled. After this has been emitted, the
 * call's `cancelled` property will be set to `true`.
 * @event grpc~ServerWritableStream~cancelled
 */

util.inherits(ServerWritableStream, Writable);

/**
 * A stream that the server can write to. Used for calls that are streaming from
 * the server side.
 * @constructor grpc~ServerWritableStream
 * @extends external:Writable
 * @borrows grpc~ServerUnaryCall#sendMetadata as
 *     grpc~ServerWritableStream#sendMetadata
 * @borrows grpc~ServerUnaryCall#getPeer as grpc~ServerWritableStream#getPeer
 * @param ***REMOVED***grpc.internal~Call***REMOVED*** call The call object to send data with
 * @param ***REMOVED***grpc.Metadata***REMOVED*** metadata The request metadata from the client
 * @param ***REMOVED***grpc~serialize***REMOVED*** serialize Serialization function for writes
 */
function ServerWritableStream(call, metadata, serialize) ***REMOVED***
  Writable.call(this, ***REMOVED***objectMode: true***REMOVED***);
  this.call = call;

  this.finished = false;
  setUpWritable(this, serialize);
  /**
   * Indicates if the call has been cancelled
   * @member ***REMOVED***boolean***REMOVED*** grpc~ServerWritableStream#cancelled
   */
  this.cancelled = false;
  /**
   * The request metadata from the client
   * @member ***REMOVED***grpc.Metadata***REMOVED*** grpc~ServerWritableStream#metadata
   */
  this.metadata = metadata;
  /**
   * The request message from the client
   * @member ***REMOVED*******REMOVED*** grpc~ServerWritableStream#request
   */
  this.request = undefined;
***REMOVED***

/**
 * Start writing a chunk of data. This is an implementation of a method required
 * for implementing stream.Writable.
 * @private
 * @param ***REMOVED***Buffer***REMOVED*** chunk The chunk of data to write
 * @param ***REMOVED***string***REMOVED*** encoding Used to pass write flags
 * @param ***REMOVED***function(Error=)***REMOVED*** callback Callback to indicate that the write is
 *     complete
 */
function _write(chunk, encoding, callback) ***REMOVED***
  /* jshint validthis: true */
  var batch = ***REMOVED******REMOVED***;
  var self = this;
  var message;
  try ***REMOVED***
    message = this.serialize(chunk);
  ***REMOVED*** catch (e) ***REMOVED***
    e.code = constants.status.INTERNAL;
    callback(e);
    return;
  ***REMOVED***
  if (!this.call.metadataSent) ***REMOVED***
    batch[grpc.opType.SEND_INITIAL_METADATA] =
        (new Metadata())._getCoreRepresentation();
    this.call.metadataSent = true;
  ***REMOVED***
  if (_.isFinite(encoding)) ***REMOVED***
    /* Attach the encoding if it is a finite number. This is the closest we
     * can get to checking that it is valid flags */
    message.grpcWriteFlags = encoding;
  ***REMOVED***
  batch[grpc.opType.SEND_MESSAGE] = message;
  this.call.startBatch(batch, function(err, value) ***REMOVED***
    if (err) ***REMOVED***
      self.emit('error', err);
      return;
    ***REMOVED***
    callback();
  ***REMOVED***);
***REMOVED***

ServerWritableStream.prototype._write = _write;

/**
 * Emitted when the call has been cancelled. After this has been emitted, the
 * call's `cancelled` property will be set to `true`.
 * @event grpc~ServerReadableStream~cancelled
 */

util.inherits(ServerReadableStream, Readable);

/**
 * A stream that the server can read from. Used for calls that are streaming
 * from the client side.
 * @constructor grpc~ServerReadableStream
 * @extends external:Readable
 * @borrows grpc~ServerUnaryCall#sendMetadata as
 *     grpc~ServerReadableStream#sendMetadata
 * @borrows grpc~ServerUnaryCall#getPeer as grpc~ServerReadableStream#getPeer
 * @param ***REMOVED***grpc.internal~Call***REMOVED*** call The call object to read data with
 * @param ***REMOVED***grpc.Metadata***REMOVED*** metadata The request metadata from the client
 * @param ***REMOVED***grpc~deserialize***REMOVED*** deserialize Deserialization function for reads
 */
function ServerReadableStream(call, metadata, deserialize) ***REMOVED***
  Readable.call(this, ***REMOVED***objectMode: true***REMOVED***);
  this.call = call;
  setUpReadable(this, deserialize);
  /**
   * Indicates if the call has been cancelled
   * @member ***REMOVED***boolean***REMOVED*** grpc~ServerReadableStream#cancelled
   */
  this.cancelled = false;
  /**
   * The request metadata from the client
   * @member ***REMOVED***grpc.Metadata***REMOVED*** grpc~ServerReadableStream#metadata
   */
  this.metadata = metadata;
***REMOVED***

/**
 * Start reading from the gRPC data source. This is an implementation of a
 * method required for implementing stream.Readable
 * @access private
 * @param ***REMOVED***number***REMOVED*** size Ignored
 */
function _read(size) ***REMOVED***
  /* jshint validthis: true */
  var self = this;
  /**
   * Callback to be called when a READ event is received. Pushes the data onto
   * the read queue and starts reading again if applicable
   * @param ***REMOVED***grpc.Event***REMOVED*** event READ event object
   */
  function readCallback(err, event) ***REMOVED***
    if (err) ***REMOVED***
      self.terminate();
      return;
    ***REMOVED***
    if (self.finished) ***REMOVED***
      self.push(null);
      return;
    ***REMOVED***
    var data = event.read;
    var deserialized;
    try ***REMOVED***
      deserialized = self.deserialize(data);
    ***REMOVED*** catch (e) ***REMOVED***
      e.code = constants.status.INTERNAL;
      self.emit('error', e);
      return;
    ***REMOVED***
    if (self.push(deserialized) && data !== null) ***REMOVED***
      var read_batch = ***REMOVED******REMOVED***;
      read_batch[grpc.opType.RECV_MESSAGE] = true;
      self.call.startBatch(read_batch, readCallback);
    ***REMOVED*** else ***REMOVED***
      self.reading = false;
    ***REMOVED***
  ***REMOVED***
  if (self.finished) ***REMOVED***
    self.push(null);
  ***REMOVED*** else ***REMOVED***
    if (!self.reading) ***REMOVED***
      self.reading = true;
      var batch = ***REMOVED******REMOVED***;
      batch[grpc.opType.RECV_MESSAGE] = true;
      self.call.startBatch(batch, readCallback);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

ServerReadableStream.prototype._read = _read;

/**
 * Emitted when the call has been cancelled. After this has been emitted, the
 * call's `cancelled` property will be set to `true`.
 * @event grpc~ServerDuplexStream~cancelled
 */

util.inherits(ServerDuplexStream, Duplex);

/**
 * A stream that the server can read from or write to. Used for calls with
 * duplex streaming.
 * @constructor grpc~ServerDuplexStream
 * @extends external:Duplex
 * @borrows grpc~ServerUnaryCall#sendMetadata as
 *     grpc~ServerDuplexStream#sendMetadata
 * @borrows grpc~ServerUnaryCall#getPeer as grpc~ServerDuplexStream#getPeer
 * @param ***REMOVED***grpc.internal~Call***REMOVED*** call Call object to proxy
 * @param ***REMOVED***grpc.Metadata***REMOVED*** metadata The request metadata from the client
 * @param ***REMOVED***grpc~serialize***REMOVED*** serialize Serialization function for requests
 * @param ***REMOVED***grpc~deserialize***REMOVED*** deserialize Deserialization function for
 *     responses
 */
function ServerDuplexStream(call, metadata, serialize, deserialize) ***REMOVED***
  Duplex.call(this, ***REMOVED***objectMode: true***REMOVED***);
  this.call = call;
  setUpWritable(this, serialize);
  setUpReadable(this, deserialize);
  /**
   * Indicates if the call has been cancelled
   * @member ***REMOVED***boolean***REMOVED*** grpc~ServerReadableStream#cancelled
   */
  this.cancelled = false;
  /**
   * The request metadata from the client
   * @member ***REMOVED***grpc.Metadata***REMOVED*** grpc~ServerReadableStream#metadata
   */
  this.metadata = metadata;
***REMOVED***

ServerDuplexStream.prototype._read = _read;
ServerDuplexStream.prototype._write = _write;

/**
 * Send the initial metadata for a writable stream.
 * @alias grpc~ServerUnaryCall#sendMetadata
 * @param ***REMOVED***Metadata***REMOVED*** responseMetadata Metadata to send
 */
function sendMetadata(responseMetadata) ***REMOVED***
  /* jshint validthis: true */
  var self = this;
  if (!this.call.metadataSent) ***REMOVED***
    this.call.metadataSent = true;
    var batch = ***REMOVED******REMOVED***;
    batch[grpc.opType.SEND_INITIAL_METADATA] =
        responseMetadata._getCoreRepresentation();
    this.call.startBatch(batch, function(err) ***REMOVED***
      if (err) ***REMOVED***
        self.emit('error', err);
        return;
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

ServerUnaryCall.prototype.sendMetadata = sendMetadata;
ServerWritableStream.prototype.sendMetadata = sendMetadata;
ServerReadableStream.prototype.sendMetadata = sendMetadata;
ServerDuplexStream.prototype.sendMetadata = sendMetadata;

/**
 * Get the endpoint this call/stream is connected to.
 * @alias grpc~ServerUnaryCall#getPeer
 * @return ***REMOVED***string***REMOVED*** The URI of the endpoint
 */
function getPeer() ***REMOVED***
  /* jshint validthis: true */
  return this.call.getPeer();
***REMOVED***

ServerUnaryCall.prototype.getPeer = getPeer;
ServerReadableStream.prototype.getPeer = getPeer;
ServerWritableStream.prototype.getPeer = getPeer;
ServerDuplexStream.prototype.getPeer = getPeer;

/**
 * Wait for the client to close, then emit a cancelled event if the client
 * cancelled.
 * @private
 */
function waitForCancel() ***REMOVED***
  /* jshint validthis: true */
  var self = this;
  var cancel_batch = ***REMOVED******REMOVED***;
  cancel_batch[grpc.opType.RECV_CLOSE_ON_SERVER] = true;
  self.call.startBatch(cancel_batch, function(err, result) ***REMOVED***
    if (err) ***REMOVED***
      self.emit('error', err);
    ***REMOVED***
    if (result.cancelled) ***REMOVED***
      self.cancelled = true;
      self.emit('cancelled');
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

ServerUnaryCall.prototype.waitForCancel = waitForCancel;
ServerReadableStream.prototype.waitForCancel = waitForCancel;
ServerWritableStream.prototype.waitForCancel = waitForCancel;
ServerDuplexStream.prototype.waitForCancel = waitForCancel;

/**
 * Callback function passed to server handlers that handle methods with unary
 * responses.
 * @callback grpc.Server~sendUnaryData
 * @param ***REMOVED***grpc~ServiceError***REMOVED*** error An error, if the call failed
 * @param ***REMOVED*******REMOVED*** value The response value. Must be a valid argument to the
 *     `responseSerialize` method of the method that is being handled
 * @param ***REMOVED***grpc.Metadata=***REMOVED*** trailer Trailing metadata to send, if applicable
 * @param ***REMOVED***grpc.writeFlags=***REMOVED*** flags Flags to modify writing the response
 */

/**
 * User-provided method to handle unary requests on a server
 * @callback grpc.Server~handleUnaryCall
 * @param ***REMOVED***grpc~ServerUnaryCall***REMOVED*** call The call object
 * @param ***REMOVED***grpc.Server~sendUnaryData***REMOVED*** callback The callback to call to respond
 *     to the request
 */

/**
 * Fully handle a unary call
 * @private
 * @param ***REMOVED***grpc.internal~Call***REMOVED*** call The call to handle
 * @param ***REMOVED***Object***REMOVED*** handler Request handler object for the method that was called
 * @param ***REMOVED***grpc~Server.handleUnaryCall***REMOVED*** handler.func The handler function
 * @param ***REMOVED***grpc~deserialize***REMOVED*** handler.deserialize The deserialization function
 *     for request data
 * @param ***REMOVED***grpc~serialize***REMOVED*** handler.serialize The serialization function for
 *     response data
 * @param ***REMOVED***grpc.Metadata***REMOVED*** metadata Metadata from the client
 */
function handleUnary(call, handler, metadata) ***REMOVED***
  var emitter = new ServerUnaryCall(call, metadata);
  emitter.on('error', function(error) ***REMOVED***
    handleError(call, error);
  ***REMOVED***);
  emitter.waitForCancel();
  var batch = ***REMOVED******REMOVED***;
  batch[grpc.opType.RECV_MESSAGE] = true;
  call.startBatch(batch, function(err, result) ***REMOVED***
    if (err) ***REMOVED***
      handleError(call, err);
      return;
    ***REMOVED***
    try ***REMOVED***
      emitter.request = handler.deserialize(result.read);
    ***REMOVED*** catch (e) ***REMOVED***
      e.code = constants.status.INTERNAL;
      handleError(call, e);
      return;
    ***REMOVED***
    if (emitter.cancelled) ***REMOVED***
      return;
    ***REMOVED***
    handler.func(emitter, function sendUnaryData(err, value, trailer, flags) ***REMOVED***
      if (err) ***REMOVED***
        if (trailer) ***REMOVED***
          err.metadata = trailer;
        ***REMOVED***
        handleError(call, err);
      ***REMOVED*** else ***REMOVED***
        sendUnaryResponse(call, value, handler.serialize, trailer, flags);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

/**
 * User provided method to handle server streaming methods on the server.
 * @callback grpc.Server~handleServerStreamingCall
 * @param ***REMOVED***grpc~ServerWritableStream***REMOVED*** call The call object
 */

/**
 * Fully handle a server streaming call
 * @private
 * @param ***REMOVED***grpc.internal~Call***REMOVED*** call The call to handle
 * @param ***REMOVED***Object***REMOVED*** handler Request handler object for the method that was called
 * @param ***REMOVED***grpc~Server.handleServerStreamingCall***REMOVED*** handler.func The handler
 *     function
 * @param ***REMOVED***grpc~deserialize***REMOVED*** handler.deserialize The deserialization function
 *     for request data
 * @param ***REMOVED***grpc~serialize***REMOVED*** handler.serialize The serialization function for
 *     response data
 * @param ***REMOVED***grpc.Metadata***REMOVED*** metadata Metadata from the client
 */
function handleServerStreaming(call, handler, metadata) ***REMOVED***
  var stream = new ServerWritableStream(call, metadata, handler.serialize);
  stream.waitForCancel();
  var batch = ***REMOVED******REMOVED***;
  batch[grpc.opType.RECV_MESSAGE] = true;
  call.startBatch(batch, function(err, result) ***REMOVED***
    if (err) ***REMOVED***
      stream.emit('error', err);
      return;
    ***REMOVED***
    try ***REMOVED***
      stream.request = handler.deserialize(result.read);
    ***REMOVED*** catch (e) ***REMOVED***
      e.code = constants.status.INTERNAL;
      stream.emit('error', e);
      return;
    ***REMOVED***
    handler.func(stream);
  ***REMOVED***);
***REMOVED***

/**
 * User provided method to handle client streaming methods on the server.
 * @callback grpc.Server~handleClientStreamingCall
 * @param ***REMOVED***grpc~ServerReadableStream***REMOVED*** call The call object
 * @param ***REMOVED***grpc.Server~sendUnaryData***REMOVED*** callback The callback to call to respond
 *     to the request
 */

/**
 * Fully handle a client streaming call
 * @access private
 * @param ***REMOVED***grpc.internal~Call***REMOVED*** call The call to handle
 * @param ***REMOVED***Object***REMOVED*** handler Request handler object for the method that was called
 * @param ***REMOVED***grpc~Server.handleClientStreamingCall***REMOVED*** handler.func The handler
 *     function
 * @param ***REMOVED***grpc~deserialize***REMOVED*** handler.deserialize The deserialization function
 *     for request data
 * @param ***REMOVED***grpc~serialize***REMOVED*** handler.serialize The serialization function for
 *     response data
 * @param ***REMOVED***grpc.Metadata***REMOVED*** metadata Metadata from the client
 */
function handleClientStreaming(call, handler, metadata) ***REMOVED***
  var stream = new ServerReadableStream(call, metadata, handler.deserialize);
  stream.on('error', function(error) ***REMOVED***
    handleError(call, error);
  ***REMOVED***);
  stream.waitForCancel();
  handler.func(stream, function(err, value, trailer, flags) ***REMOVED***
    stream.terminate();
    if (err) ***REMOVED***
      if (trailer) ***REMOVED***
        err.metadata = trailer;
      ***REMOVED***
      handleError(call, err);
    ***REMOVED*** else ***REMOVED***
      sendUnaryResponse(call, value, handler.serialize, trailer, flags);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

/**
 * User provided method to handle bidirectional streaming calls on the server.
 * @callback grpc.Server~handleBidiStreamingCall
 * @param ***REMOVED***grpc~ServerDuplexStream***REMOVED*** call The call object
 */

/**
 * Fully handle a bidirectional streaming call
 * @private
 * @param ***REMOVED***grpc.internal~Call***REMOVED*** call The call to handle
 * @param ***REMOVED***Object***REMOVED*** handler Request handler object for the method that was called
 * @param ***REMOVED***grpc~Server.handleBidiStreamingCall***REMOVED*** handler.func The handler
 *     function
 * @param ***REMOVED***grpc~deserialize***REMOVED*** handler.deserialize The deserialization function
 *     for request data
 * @param ***REMOVED***grpc~serialize***REMOVED*** handler.serialize The serialization function for
 *     response data
 * @param ***REMOVED***Metadata***REMOVED*** metadata Metadata from the client
 */
function handleBidiStreaming(call, handler, metadata) ***REMOVED***
  var stream = new ServerDuplexStream(call, metadata, handler.serialize,
                                      handler.deserialize);
  stream.waitForCancel();
  handler.func(stream);
***REMOVED***

var streamHandlers = ***REMOVED***
  unary: handleUnary,
  server_stream: handleServerStreaming,
  client_stream: handleClientStreaming,
  bidi: handleBidiStreaming
***REMOVED***;

/**
 * Constructs a server object that stores request handlers and delegates
 * incoming requests to those handlers
 * @memberof grpc
 * @constructor
 * @param ***REMOVED***Object=***REMOVED*** options Options that should be passed to the internal server
 *     implementation
 * @example
 * var server = new grpc.Server();
 * server.addProtoService(protobuf_service_descriptor, service_implementation);
 * server.bind('address:port', server_credential);
 * server.start();
 */
function Server(options) ***REMOVED***
  this.handlers = ***REMOVED******REMOVED***;
  var server = new grpc.Server(options);
  this._server = server;
  this.started = false;
***REMOVED***

/**
 * Start the server and begin handling requests
 */
Server.prototype.start = function() ***REMOVED***
  if (this.started) ***REMOVED***
    throw new Error('Server is already running');
  ***REMOVED***
  var self = this;
  this.started = true;
  this._server.start();
  /**
   * Handles the SERVER_RPC_NEW event. If there is a handler associated with
   * the requested method, use that handler to respond to the request. Then
   * wait for the next request
   * @param ***REMOVED***grpc.internal~Event***REMOVED*** event The event to handle with tag
   *     SERVER_RPC_NEW
   */
  function handleNewCall(err, event) ***REMOVED***
    if (err) ***REMOVED***
      return;
    ***REMOVED***
    var details = event.new_call;
    var call = details.call;
    var method = details.method;
    var metadata = Metadata._fromCoreRepresentation(details.metadata);
    if (method === null) ***REMOVED***
      return;
    ***REMOVED***
    self._server.requestCall(handleNewCall);
    var handler;
    if (self.handlers.hasOwnProperty(method)) ***REMOVED***
      handler = self.handlers[method];
    ***REMOVED*** else ***REMOVED***
      var batch = ***REMOVED******REMOVED***;
      batch[grpc.opType.SEND_INITIAL_METADATA] =
          (new Metadata())._getCoreRepresentation();
      batch[grpc.opType.SEND_STATUS_FROM_SERVER] = ***REMOVED***
        code: constants.status.UNIMPLEMENTED,
        details: '',
        metadata: ***REMOVED******REMOVED***
      ***REMOVED***;
      batch[grpc.opType.RECV_CLOSE_ON_SERVER] = true;
      call.startBatch(batch, function() ***REMOVED******REMOVED***);
      return;
    ***REMOVED***
    streamHandlers[handler.type](call, handler, metadata);
  ***REMOVED***
  this._server.requestCall(handleNewCall);
***REMOVED***;

/**
 * Unified type for application handlers for all types of calls
 * @typedef ***REMOVED***(grpc.Server~handleUnaryCall
 *            |grpc.Server~handleClientStreamingCall
 *            |grpc.Server~handleServerStreamingCall
 *            |grpc.Server~handleBidiStreamingCall)***REMOVED*** grpc.Server~handleCall
 */

/**
 * Registers a handler to handle the named method. Fails if there already is
 * a handler for the given method. Returns true on success
 * @param ***REMOVED***string***REMOVED*** name The name of the method that the provided function should
 *     handle/respond to.
 * @param ***REMOVED***grpc.Server~handleCall***REMOVED*** handler Function that takes a stream of
 *     request values and returns a stream of response values
 * @param ***REMOVED***grpc~serialize***REMOVED*** serialize Serialization function for responses
 * @param ***REMOVED***grpc~deserialize***REMOVED*** deserialize Deserialization function for requests
 * @param ***REMOVED***string***REMOVED*** type The streaming type of method that this handles
 * @return ***REMOVED***boolean***REMOVED*** True if the handler was set. False if a handler was already
 *     set for that name.
 */
Server.prototype.register = function(name, handler, serialize, deserialize,
                                     type) ***REMOVED***
  if (this.handlers.hasOwnProperty(name)) ***REMOVED***
    return false;
  ***REMOVED***
  this.handlers[name] = ***REMOVED***
    func: handler,
    serialize: serialize,
    deserialize: deserialize,
    type: type
  ***REMOVED***;
  return true;
***REMOVED***;

/**
 * Gracefully shuts down the server. The server will stop receiving new calls,
 * and any pending calls will complete. The callback will be called when all
 * pending calls have completed and the server is fully shut down. This method
 * is idempotent with itself and forceShutdown.
 * @param ***REMOVED***function()***REMOVED*** callback The shutdown complete callback
 */
Server.prototype.tryShutdown = function(callback) ***REMOVED***
  this._server.tryShutdown(callback);
***REMOVED***;

/**
 * Forcibly shuts down the server. The server will stop receiving new calls
 * and cancel all pending calls. When it returns, the server has shut down.
 * This method is idempotent with itself and tryShutdown, and it will trigger
 * any outstanding tryShutdown callbacks.
 */
Server.prototype.forceShutdown = function() ***REMOVED***
  this._server.forceShutdown();
***REMOVED***;

var unimplementedStatusResponse = ***REMOVED***
  code: constants.status.UNIMPLEMENTED,
  details: 'The server does not implement this method'
***REMOVED***;

var defaultHandler = ***REMOVED***
  unary: function(call, callback) ***REMOVED***
    callback(unimplementedStatusResponse);
  ***REMOVED***,
  client_stream: function(call, callback) ***REMOVED***
    callback(unimplementedStatusResponse);
  ***REMOVED***,
  server_stream: function(call) ***REMOVED***
    call.emit('error', unimplementedStatusResponse);
  ***REMOVED***,
  bidi: function(call) ***REMOVED***
    call.emit('error', unimplementedStatusResponse);
  ***REMOVED***
***REMOVED***;

/**
 * Add a service to the server, with a corresponding implementation.
 * @param ***REMOVED***grpc~ServiceDefinition***REMOVED*** service The service descriptor
 * @param ***REMOVED***Object<String, grpc.Server~handleCall>***REMOVED*** implementation Map of method
 *     names to method implementation for the provided service.
 */
Server.prototype.addService = function(service, implementation) ***REMOVED***
  if (!_.isObject(service) || !_.isObject(implementation)) ***REMOVED***
    throw new Error('addService requires two objects as arguments');
  ***REMOVED***
  if (_.keys(service).length === 0) ***REMOVED***
    throw new Error('Cannot add an empty service to a server');
  ***REMOVED***
  if (this.started) ***REMOVED***
    throw new Error('Can\'t add a service to a started server.');
  ***REMOVED***
  var self = this;
  _.forOwn(service, function(attrs, name) ***REMOVED***
    var method_type;
    if (attrs.requestStream) ***REMOVED***
      if (attrs.responseStream) ***REMOVED***
        method_type = 'bidi';
      ***REMOVED*** else ***REMOVED***
        method_type = 'client_stream';
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      if (attrs.responseStream) ***REMOVED***
        method_type = 'server_stream';
      ***REMOVED*** else ***REMOVED***
        method_type = 'unary';
      ***REMOVED***
    ***REMOVED***
    var impl;
    if (implementation[name] === undefined) ***REMOVED***
      /* Handle the case where the method is passed with the name exactly as
         written in the proto file, instead of using JavaScript function
         naming style */
      if (implementation[attrs.originalName] === undefined) ***REMOVED***
        common.log(constants.logVerbosity.ERROR, 'Method handler ' + name +
            ' for ' + attrs.path + ' expected but not provided');
        impl = defaultHandler[method_type];
      ***REMOVED*** else ***REMOVED***
        impl = _.bind(implementation[attrs.originalName], implementation);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      impl = _.bind(implementation[name], implementation);
    ***REMOVED***
    var serialize = attrs.responseSerialize;
    var deserialize = attrs.requestDeserialize;
    var register_success = self.register(attrs.path, impl, serialize,
                                         deserialize, method_type);
    if (!register_success) ***REMOVED***
      throw new Error('Method handler for ' + attrs.path +
          ' already provided.');
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;

/**
 * Add a proto service to the server, with a corresponding implementation
 * @deprecated Use ***REMOVED***@link grpc.Server#addService***REMOVED*** instead
 * @param ***REMOVED***Protobuf.Reflect.Service***REMOVED*** service The proto service descriptor
 * @param ***REMOVED***Object<String, grpc.Server~handleCall>***REMOVED*** implementation Map of method
 *     names to method implementation for the provided service.
 */
Server.prototype.addProtoService = util.deprecate(function(service,
                                                           implementation) ***REMOVED***
  var options;
  var protobuf_js_5_common = require('./protobuf_js_5_common');
  var protobuf_js_6_common = require('./protobuf_js_6_common');
  if (protobuf_js_5_common.isProbablyProtobufJs5(service)) ***REMOVED***
    options = _.defaults(service.grpc_options, common.defaultGrpcOptions);
    this.addService(
        protobuf_js_5_common.getProtobufServiceAttrs(service, options),
        implementation);
  ***REMOVED*** else if (protobuf_js_6_common.isProbablyProtobufJs6(service)) ***REMOVED***
    options = _.defaults(service.grpc_options, common.defaultGrpcOptions);
    this.addService(
        protobuf_js_6_common.getProtobufServiceAttrs(service, options),
        implementation);
  ***REMOVED*** else ***REMOVED***
    // We assume that this is a service attributes object
    this.addService(service, implementation);
  ***REMOVED***
***REMOVED***, 'Server#addProtoService: Use Server#addService instead');

/**
 * Binds the server to the given port, with SSL disabled if creds is an
 * insecure credentials object
 * @param ***REMOVED***string***REMOVED*** port The port that the server should bind on, in the format
 *     "address:port"
 * @param ***REMOVED***grpc.ServerCredentials***REMOVED*** creds Server credential object to be used for
 *     SSL. Pass an insecure credentials object for an insecure port.
 */
Server.prototype.bind = function(port, creds) ***REMOVED***
  if (this.started) ***REMOVED***
    throw new Error('Can\'t bind an already running server to an address');
  ***REMOVED***
  return this._server.addHttp2Port(port, creds);
***REMOVED***;

exports.Server = Server;
