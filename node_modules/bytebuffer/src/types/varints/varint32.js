//? if (VARINT32) ***REMOVED***
// types/varints/varint32

/**
 * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
 * @type ***REMOVED***number***REMOVED***
 * @const
 * @expose
 */
ByteBuffer.MAX_VARINT32_BYTES = 5;

/**
 * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
 * @param ***REMOVED***number***REMOVED*** value Value to encode
 * @returns ***REMOVED***number***REMOVED*** Number of bytes required. Capped to ***REMOVED***@link ByteBuffer.MAX_VARINT32_BYTES***REMOVED***
 * @expose
 */
ByteBuffer.calculateVarint32 = function(value) ***REMOVED***
    // ref: src/google/protobuf/io/coded_stream.cc
    value = value >>> 0;
         if (value < 1 << 7 ) return 1;
    else if (value < 1 << 14) return 2;
    else if (value < 1 << 21) return 3;
    else if (value < 1 << 28) return 4;
    else                      return 5;
***REMOVED***;

/**
 * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
 * @param ***REMOVED***number***REMOVED*** n Signed 32bit integer
 * @returns ***REMOVED***number***REMOVED*** Unsigned zigzag encoded 32bit integer
 * @expose
 */
ByteBuffer.zigZagEncode32 = function(n) ***REMOVED***
    return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
***REMOVED***;

/**
 * Decodes a zigzag encoded signed 32bit integer.
 * @param ***REMOVED***number***REMOVED*** n Unsigned zigzag encoded 32bit integer
 * @returns ***REMOVED***number***REMOVED*** Signed 32bit integer
 * @expose
 */
ByteBuffer.zigZagDecode32 = function(n) ***REMOVED***
    return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
***REMOVED***;

/**
 * Writes a 32bit base 128 variable-length integer.
 * @param ***REMOVED***number***REMOVED*** value Value to write
 * @param ***REMOVED***number=***REMOVED*** offset Offset to write to. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
 *  written if omitted.
 * @returns ***REMOVED***!ByteBuffer|number***REMOVED*** this if `offset` is omitted, else the actual number of bytes written
 * @expose
 */
ByteBufferPrototype.writeVarint32 = function(value, offset) ***REMOVED***
    //? RELATIVE();
    if (!this.noAssert) ***REMOVED***
        //? ASSERT_INTEGER('value');
        //? ASSERT_OFFSET();
    ***REMOVED***
    var size = ByteBuffer.calculateVarint32(value),
        b;
    //? ENSURE_CAPACITY('size');
    value >>>= 0;
    while (value >= 0x80) ***REMOVED***
        b = (value & 0x7f) | 0x80;
        //? if (NODE)
        this.buffer[offset++] = b;
        //? else if (DATAVIEW)
        this.view.setUint8(offset++, b);
        //? else
        this.view[offset++] = b;
        value >>>= 7;
    ***REMOVED***
    //? if (NODE)
    this.buffer[offset++] = value;
    //? else if (DATAVIEW)
    this.view.setUint8(offset++, value);
    //? else
    this.view[offset++] = value;
    if (relative) ***REMOVED***
        this.offset = offset;
        return this;
    ***REMOVED***
    return size;
***REMOVED***;

/**
 * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
 * @param ***REMOVED***number***REMOVED*** value Value to write
 * @param ***REMOVED***number=***REMOVED*** offset Offset to write to. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
 *  written if omitted.
 * @returns ***REMOVED***!ByteBuffer|number***REMOVED*** this if `offset` is omitted, else the actual number of bytes written
 * @expose
 */
ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) ***REMOVED***
    return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
***REMOVED***;

/**
 * Reads a 32bit base 128 variable-length integer.
 * @param ***REMOVED***number=***REMOVED*** offset Offset to read from. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
 *  written if omitted.
 * @returns ***REMOVED***number|!***REMOVED***value: number, length: number***REMOVED******REMOVED*** The value read if offset is omitted, else the value read
 *  and the actual number of bytes read.
 * @throws ***REMOVED***Error***REMOVED*** If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
 *  to fully decode the varint.
 * @expose
 */
ByteBufferPrototype.readVarint32 = function(offset) ***REMOVED***
    //? RELATIVE();
    if (!this.noAssert) ***REMOVED***
        //? ASSERT_OFFSET(1);
    ***REMOVED***
    var c = 0,
        value = 0 >>> 0,
        b;
    do ***REMOVED***
        if (!this.noAssert && offset > this.limit) ***REMOVED***
            var err = Error("Truncated");
            err['truncated'] = true;
            throw err;
        ***REMOVED***
        //? if (NODE)
        b = this.buffer[offset++];
        //? else if (DATAVIEW)
        b = this.view.getUint8(offset++);
        //? else
        b = this.view[offset++];
        if (c < 5)
            value |= (b & 0x7f) << (7*c);
        ++c;
    ***REMOVED*** while ((b & 0x80) !== 0);
    value |= 0;
    if (relative) ***REMOVED***
        this.offset = offset;
        return value;
    ***REMOVED***
    return ***REMOVED***
        "value": value,
        "length": c
    ***REMOVED***;
***REMOVED***;

/**
 * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
 * @param ***REMOVED***number=***REMOVED*** offset Offset to read from. Will use and increase ***REMOVED***@link ByteBuffer#offset***REMOVED*** by the number of bytes
 *  written if omitted.
 * @returns ***REMOVED***number|!***REMOVED***value: number, length: number***REMOVED******REMOVED*** The value read if offset is omitted, else the value read
 *  and the actual number of bytes read.
 * @throws ***REMOVED***Error***REMOVED*** If it's not a valid varint
 * @expose
 */
ByteBufferPrototype.readVarint32ZigZag = function(offset) ***REMOVED***
    var val = this.readVarint32(offset);
    if (typeof val === 'object')
        val["value"] = ByteBuffer.zigZagDecode32(val["value"]);
    else
        val = ByteBuffer.zigZagDecode32(val);
    return val;
***REMOVED***;

//? ***REMOVED***