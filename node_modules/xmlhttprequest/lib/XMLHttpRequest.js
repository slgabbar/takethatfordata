/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @license MIT
 */

var Url = require("url");
var spawn = require("child_process").spawn;
var fs = require("fs");

exports.XMLHttpRequest = function() ***REMOVED***
  "use strict";

  /**
   * Private variables
   */
  var self = this;
  var http = require("http");
  var https = require("https");

  // Holds http.js objects
  var request;
  var response;

  // Request settings
  var settings = ***REMOVED******REMOVED***;

  // Disable header blacklist.
  // Not part of XHR specs.
  var disableHeaderCheck = false;

  // Set some default headers
  var defaultHeaders = ***REMOVED***
    "User-Agent": "node-XMLHttpRequest",
    "Accept": "*/*",
  ***REMOVED***;

  var headers = ***REMOVED******REMOVED***;
  var headersCase = ***REMOVED******REMOVED***;

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  var forbiddenRequestHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "content-transfer-encoding",
    "cookie",
    "cookie2",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];

  // These request methods are not allowed
  var forbiddenRequestMethods = [
    "TRACE",
    "TRACK",
    "CONNECT"
  ];

  // Send flag
  var sendFlag = false;
  // Error flag, used when errors occur or abort is called
  var errorFlag = false;

  // Event listeners
  var listeners = ***REMOVED******REMOVED***;

  /**
   * Constants
   */

  this.UNSENT = 0;
  this.OPENED = 1;
  this.HEADERS_RECEIVED = 2;
  this.LOADING = 3;
  this.DONE = 4;

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT;

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null;

  // Result & response
  this.responseText = "";
  this.responseXML = "";
  this.status = null;
  this.statusText = null;
  
  // Whether cross-site Access-Control requests should be made using
  // credentials such as cookies or authorization headers
  this.withCredentials = false;

  /**
   * Private methods
   */

  /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpHeader = function(header) ***REMOVED***
    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
  ***REMOVED***;

  /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpMethod = function(method) ***REMOVED***
    return (method && forbiddenRequestMethods.indexOf(method) === -1);
  ***REMOVED***;

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */
  this.open = function(method, url, async, user, password) ***REMOVED***
    this.abort();
    errorFlag = false;

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) ***REMOVED***
      throw new Error("SecurityError: Request method not allowed");
    ***REMOVED***

    settings = ***REMOVED***
      "method": method,
      "url": url.toString(),
      "async": (typeof async !== "boolean" ? true : async),
      "user": user || null,
      "password": password || null
    ***REMOVED***;

    setState(this.OPENED);
  ***REMOVED***;

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function(state) ***REMOVED***
    disableHeaderCheck = state;
  ***REMOVED***;

  /**
   * Sets a header for the request or appends the value if one is already set.
   *
   * @param string header Header name
   * @param string value Header value
   */
  this.setRequestHeader = function(header, value) ***REMOVED***
    if (this.readyState !== this.OPENED) ***REMOVED***
      throw new Error("INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN");
    ***REMOVED***
    if (!isAllowedHttpHeader(header)) ***REMOVED***
      console.warn("Refused to set unsafe header \"" + header + "\"");
      return;
    ***REMOVED***
    if (sendFlag) ***REMOVED***
      throw new Error("INVALID_STATE_ERR: send flag is true");
    ***REMOVED***
    header = headersCase[header.toLowerCase()] || header;
    headersCase[header.toLowerCase()] = header;
    headers[header] = headers[header] ? headers[header] + ', ' + value : value;
  ***REMOVED***;

  /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn't exist.
   */
  this.getResponseHeader = function(header) ***REMOVED***
    if (typeof header === "string"
      && this.readyState > this.OPENED
      && response
      && response.headers
      && response.headers[header.toLowerCase()]
      && !errorFlag
    ) ***REMOVED***
      return response.headers[header.toLowerCase()];
    ***REMOVED***

    return null;
  ***REMOVED***;

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function() ***REMOVED***
    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) ***REMOVED***
      return "";
    ***REMOVED***
    var result = "";

    for (var i in response.headers) ***REMOVED***
      // Cookie headers are excluded
      if (i !== "set-cookie" && i !== "set-cookie2") ***REMOVED***
        result += i + ": " + response.headers[i] + "\r\n";
      ***REMOVED***
    ***REMOVED***
    return result.substr(0, result.length - 2);
  ***REMOVED***;

  /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */
  this.getRequestHeader = function(name) ***REMOVED***
    if (typeof name === "string" && headersCase[name.toLowerCase()]) ***REMOVED***
      return headers[headersCase[name.toLowerCase()]];
    ***REMOVED***

    return "";
  ***REMOVED***;

  /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */
  this.send = function(data) ***REMOVED***
    if (this.readyState !== this.OPENED) ***REMOVED***
      throw new Error("INVALID_STATE_ERR: connection must be opened before send() is called");
    ***REMOVED***

    if (sendFlag) ***REMOVED***
      throw new Error("INVALID_STATE_ERR: send has already been called");
    ***REMOVED***

    var ssl = false, local = false;
    var url = Url.parse(settings.url);
    var host;
    // Determine the server
    switch (url.protocol) ***REMOVED***
      case "https:":
        ssl = true;
        // SSL & non-SSL both need host, no break here.
      case "http:":
        host = url.hostname;
        break;

      case "file:":
        local = true;
        break;

      case undefined:
      case null:
      case "":
        host = "localhost";
        break;

      default:
        throw new Error("Protocol not supported.");
    ***REMOVED***

    // Load files off the local filesystem (file://)
    if (local) ***REMOVED***
      if (settings.method !== "GET") ***REMOVED***
        throw new Error("XMLHttpRequest: Only GET method is supported");
      ***REMOVED***

      if (settings.async) ***REMOVED***
        fs.readFile(url.pathname, "utf8", function(error, data) ***REMOVED***
          if (error) ***REMOVED***
            self.handleError(error);
          ***REMOVED*** else ***REMOVED***
            self.status = 200;
            self.responseText = data;
            setState(self.DONE);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        try ***REMOVED***
          this.responseText = fs.readFileSync(url.pathname, "utf8");
          this.status = 200;
          setState(self.DONE);
        ***REMOVED*** catch(e) ***REMOVED***
          this.handleError(e);
        ***REMOVED***
      ***REMOVED***

      return;
    ***REMOVED***

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    var port = url.port || (ssl ? 443 : 80);
    // Add query string if one is used
    var uri = url.pathname + (url.search ? url.search : "");

    // Set the defaults if they haven't been set
    for (var name in defaultHeaders) ***REMOVED***
      if (!headersCase[name.toLowerCase()]) ***REMOVED***
        headers[name] = defaultHeaders[name];
      ***REMOVED***
    ***REMOVED***

    // Set the Host header or the server may reject the request
    headers.Host = host;
    if (!((ssl && port === 443) || port === 80)) ***REMOVED***
      headers.Host += ":" + url.port;
    ***REMOVED***

    // Set Basic Auth if necessary
    if (settings.user) ***REMOVED***
      if (typeof settings.password === "undefined") ***REMOVED***
        settings.password = "";
      ***REMOVED***
      var authBuf = new Buffer(settings.user + ":" + settings.password);
      headers.Authorization = "Basic " + authBuf.toString("base64");
    ***REMOVED***

    // Set content length header
    if (settings.method === "GET" || settings.method === "HEAD") ***REMOVED***
      data = null;
    ***REMOVED*** else if (data) ***REMOVED***
      headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);

      if (!headers["Content-Type"]) ***REMOVED***
        headers["Content-Type"] = "text/plain;charset=UTF-8";
      ***REMOVED***
    ***REMOVED*** else if (settings.method === "POST") ***REMOVED***
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don't meet the specs.
      headers["Content-Length"] = 0;
    ***REMOVED***

    var options = ***REMOVED***
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: false,
      withCredentials: self.withCredentials
    ***REMOVED***;

    // Reset error flag
    errorFlag = false;

    // Handle async requests
    if (settings.async) ***REMOVED***
      // Use the proper protocol
      var doRequest = ssl ? https.request : http.request;

      // Request is being sent, set send flag
      sendFlag = true;

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent("readystatechange");

      // Handler for the response
      var responseHandler = function responseHandler(resp) ***REMOVED***
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp;
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) ***REMOVED***
          // Change URL to the redirect location
          settings.url = response.headers.location;
          var url = Url.parse(settings.url);
          // Set host var in case it's used later
          host = url.hostname;
          // Options for the new request
          var newOptions = ***REMOVED***
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? "GET" : settings.method,
            headers: headers,
            withCredentials: self.withCredentials
          ***REMOVED***;

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on("error", errorHandler);
          request.end();
          // @TODO Check if an XHR event needs to be fired here
          return;
        ***REMOVED***

        response.setEncoding("utf8");

        setState(self.HEADERS_RECEIVED);
        self.status = response.statusCode;

        response.on("data", function(chunk) ***REMOVED***
          // Make sure there's some data
          if (chunk) ***REMOVED***
            self.responseText += chunk;
          ***REMOVED***
          // Don't emit state changes if the connection has been aborted.
          if (sendFlag) ***REMOVED***
            setState(self.LOADING);
          ***REMOVED***
        ***REMOVED***);

        response.on("end", function() ***REMOVED***
          if (sendFlag) ***REMOVED***
            // Discard the end event if the connection has been aborted
            setState(self.DONE);
            sendFlag = false;
          ***REMOVED***
        ***REMOVED***);

        response.on("error", function(error) ***REMOVED***
          self.handleError(error);
        ***REMOVED***);
      ***REMOVED***;

      // Error handler for the request
      var errorHandler = function errorHandler(error) ***REMOVED***
        self.handleError(error);
      ***REMOVED***;

      // Create the request
      request = doRequest(options, responseHandler).on("error", errorHandler);

      // Node 0.4 and later won't accept empty data. Make sure it's needed.
      if (data) ***REMOVED***
        request.write(data);
      ***REMOVED***

      request.end();

      self.dispatchEvent("loadstart");
    ***REMOVED*** else ***REMOVED*** // Synchronous
      // Create a temporary file for communication with the other Node process
      var contentFile = ".node-xmlhttprequest-content-" + process.pid;
      var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
      fs.writeFileSync(syncFile, "", "utf8");
      // The async request the other Node process executes
      var execString = "var http = require('http'), https = require('https'), fs = require('fs');"
        + "var doRequest = http" + (ssl ? "s" : "") + ".request;"
        + "var options = " + JSON.stringify(options) + ";"
        + "var responseText = '';"
        + "var req = doRequest(options, function(response) ***REMOVED***"
        + "response.setEncoding('utf8');"
        + "response.on('data', function(chunk) ***REMOVED***"
        + "  responseText += chunk;"
        + "***REMOVED***);"
        + "response.on('end', function() ***REMOVED***"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify(***REMOVED***err: null, data: ***REMOVED***statusCode: response.statusCode, headers: response.headers, text: responseText***REMOVED******REMOVED***), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "***REMOVED***);"
        + "response.on('error', function(error) ***REMOVED***"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify(***REMOVED***err: error***REMOVED***), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "***REMOVED***);"
        + "***REMOVED***).on('error', function(error) ***REMOVED***"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify(***REMOVED***err: error***REMOVED***), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "***REMOVED***);"
        + (data ? "req.write('" + JSON.stringify(data).slice(1,-1).replace(/'/g, "\\'") + "');":"")
        + "req.end();";
      // Start the other Node Process, executing this string
      var syncProc = spawn(process.argv[0], ["-e", execString]);
      while(fs.existsSync(syncFile)) ***REMOVED***
        // Wait while the sync file is empty
      ***REMOVED***
      var resp = JSON.parse(fs.readFileSync(contentFile, 'utf8'));
      // Kill the child process once the file has data
      syncProc.stdin.end();
      // Remove the temporary file
      fs.unlinkSync(contentFile);

      if (resp.err) ***REMOVED***
        self.handleError(resp.err);
      ***REMOVED*** else ***REMOVED***
        response = resp.data;
        self.status = resp.data.statusCode;
        self.responseText = resp.data.text;
        setState(self.DONE);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function(error) ***REMOVED***
    this.status = 0;
    this.statusText = error;
    this.responseText = error.stack;
    errorFlag = true;
    setState(this.DONE);
    this.dispatchEvent('error');
  ***REMOVED***;

  /**
   * Aborts a request.
   */
  this.abort = function() ***REMOVED***
    if (request) ***REMOVED***
      request.abort();
      request = null;
    ***REMOVED***

    headers = defaultHeaders;
    this.status = 0;
    this.responseText = "";
    this.responseXML = "";

    errorFlag = true;

    if (this.readyState !== this.UNSENT
        && (this.readyState !== this.OPENED || sendFlag)
        && this.readyState !== this.DONE) ***REMOVED***
      sendFlag = false;
      setState(this.DONE);
    ***REMOVED***
    this.readyState = this.UNSENT;
    this.dispatchEvent('abort');
  ***REMOVED***;

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function(event, callback) ***REMOVED***
    if (!(event in listeners)) ***REMOVED***
      listeners[event] = [];
    ***REMOVED***
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback);
  ***REMOVED***;

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function(event, callback) ***REMOVED***
    if (event in listeners) ***REMOVED***
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function(ev) ***REMOVED***
        return ev !== callback;
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***;

  /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */
  this.dispatchEvent = function(event) ***REMOVED***
    if (typeof self["on" + event] === "function") ***REMOVED***
      self["on" + event]();
    ***REMOVED***
    if (event in listeners) ***REMOVED***
      for (var i = 0, len = listeners[event].length; i < len; i++) ***REMOVED***
        listeners[event][i].call(self);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */
  var setState = function(state) ***REMOVED***
    if (state == self.LOADING || self.readyState !== state) ***REMOVED***
      self.readyState = state;

      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) ***REMOVED***
        self.dispatchEvent("readystatechange");
      ***REMOVED***

      if (self.readyState === self.DONE && !errorFlag) ***REMOVED***
        self.dispatchEvent("load");
        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
        self.dispatchEvent("loadend");
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
***REMOVED***;
