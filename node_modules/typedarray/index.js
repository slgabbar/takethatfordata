var undefined = (void 0); // Paranoia

// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to
// create, and consume so much memory, that the browser appears frozen.
var MAX_ARRAY_LENGTH = 1e5;

// Approximations of internal ECMAScript conversion functions
var ECMAScript = (function() ***REMOVED***
  // Stash a copy in case other scripts modify these
  var opts = Object.prototype.toString,
      ophop = Object.prototype.hasOwnProperty;

  return ***REMOVED***
    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
    Class: function(v) ***REMOVED*** return opts.call(v).replace(/^\[object *|\]$/g, ''); ***REMOVED***,
    HasProperty: function(o, p) ***REMOVED*** return p in o; ***REMOVED***,
    HasOwnProperty: function(o, p) ***REMOVED*** return ophop.call(o, p); ***REMOVED***,
    IsCallable: function(o) ***REMOVED*** return typeof o === 'function'; ***REMOVED***,
    ToInt32: function(v) ***REMOVED*** return v >> 0; ***REMOVED***,
    ToUint32: function(v) ***REMOVED*** return v >>> 0; ***REMOVED***
  ***REMOVED***;
***REMOVED***());

// Snapshot intrinsics
var LN2 = Math.LN2,
    abs = Math.abs,
    floor = Math.floor,
    log = Math.log,
    min = Math.min,
    pow = Math.pow,
    round = Math.round;

// ES5: lock down object properties
function configureProperties(obj) ***REMOVED***
  if (getOwnPropNames && defineProp) ***REMOVED***
    var props = getOwnPropNames(obj), i;
    for (i = 0; i < props.length; i += 1) ***REMOVED***
      defineProp(obj, props[i], ***REMOVED***
        value: obj[props[i]],
        writable: false,
        enumerable: false,
        configurable: false
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

// emulate ES5 getter/setter API using legacy APIs
// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx
// (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but
// note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)
var defineProp
if (Object.defineProperty && (function() ***REMOVED***
      try ***REMOVED***
        Object.defineProperty(***REMOVED******REMOVED***, 'x', ***REMOVED******REMOVED***);
        return true;
      ***REMOVED*** catch (e) ***REMOVED***
        return false;
      ***REMOVED***
    ***REMOVED***)()) ***REMOVED***
  defineProp = Object.defineProperty;
***REMOVED*** else ***REMOVED***
  defineProp = function(o, p, desc) ***REMOVED***
    if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
    if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) ***REMOVED*** Object.prototype.__defineGetter__.call(o, p, desc.get); ***REMOVED***
    if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) ***REMOVED*** Object.prototype.__defineSetter__.call(o, p, desc.set); ***REMOVED***
    if (ECMAScript.HasProperty(desc, 'value')) ***REMOVED*** o[p] = desc.value; ***REMOVED***
    return o;
  ***REMOVED***;
***REMOVED***

var getOwnPropNames = Object.getOwnPropertyNames || function (o) ***REMOVED***
  if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
  var props = [], p;
  for (p in o) ***REMOVED***
    if (ECMAScript.HasOwnProperty(o, p)) ***REMOVED***
      props.push(p);
    ***REMOVED***
  ***REMOVED***
  return props;
***REMOVED***;

// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)
// for index in 0 ... obj.length
function makeArrayAccessors(obj) ***REMOVED***
  if (!defineProp) ***REMOVED*** return; ***REMOVED***

  if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");

  function makeArrayAccessor(index) ***REMOVED***
    defineProp(obj, index, ***REMOVED***
      'get': function() ***REMOVED*** return obj._getter(index); ***REMOVED***,
      'set': function(v) ***REMOVED*** obj._setter(index, v); ***REMOVED***,
      enumerable: true,
      configurable: false
    ***REMOVED***);
  ***REMOVED***

  var i;
  for (i = 0; i < obj.length; i += 1) ***REMOVED***
    makeArrayAccessor(i);
  ***REMOVED***
***REMOVED***

// Internal conversion functions:
//    pack<Type>()   - take a number (interpreted as Type), output a byte array
//    unpack<Type>() - take a byte array, output a Type-like number

function as_signed(value, bits) ***REMOVED*** var s = 32 - bits; return (value << s) >> s; ***REMOVED***
function as_unsigned(value, bits) ***REMOVED*** var s = 32 - bits; return (value << s) >>> s; ***REMOVED***

function packI8(n) ***REMOVED*** return [n & 0xff]; ***REMOVED***
function unpackI8(bytes) ***REMOVED*** return as_signed(bytes[0], 8); ***REMOVED***

function packU8(n) ***REMOVED*** return [n & 0xff]; ***REMOVED***
function unpackU8(bytes) ***REMOVED*** return as_unsigned(bytes[0], 8); ***REMOVED***

function packU8Clamped(n) ***REMOVED*** n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; ***REMOVED***

function packI16(n) ***REMOVED*** return [(n >> 8) & 0xff, n & 0xff]; ***REMOVED***
function unpackI16(bytes) ***REMOVED*** return as_signed(bytes[0] << 8 | bytes[1], 16); ***REMOVED***

function packU16(n) ***REMOVED*** return [(n >> 8) & 0xff, n & 0xff]; ***REMOVED***
function unpackU16(bytes) ***REMOVED*** return as_unsigned(bytes[0] << 8 | bytes[1], 16); ***REMOVED***

function packI32(n) ***REMOVED*** return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; ***REMOVED***
function unpackI32(bytes) ***REMOVED*** return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); ***REMOVED***

function packU32(n) ***REMOVED*** return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; ***REMOVED***
function unpackU32(bytes) ***REMOVED*** return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); ***REMOVED***

function packIEEE754(v, ebits, fbits) ***REMOVED***

  var bias = (1 << (ebits - 1)) - 1,
      s, e, f, ln,
      i, bits, str, bytes;

  function roundToEven(n) ***REMOVED***
    var w = floor(n), f = n - w;
    if (f < 0.5)
      return w;
    if (f > 0.5)
      return w + 1;
    return w % 2 ? w + 1 : w;
  ***REMOVED***

  // Compute sign, exponent, fraction
  if (v !== v) ***REMOVED***
    // NaN
    // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
    e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;
  ***REMOVED*** else if (v === Infinity || v === -Infinity) ***REMOVED***
    e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;
  ***REMOVED*** else if (v === 0) ***REMOVED***
    e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;
  ***REMOVED*** else ***REMOVED***
    s = v < 0;
    v = abs(v);

    if (v >= pow(2, 1 - bias)) ***REMOVED***
      e = min(floor(log(v) / LN2), 1023);
      f = roundToEven(v / pow(2, e) * pow(2, fbits));
      if (f / pow(2, fbits) >= 2) ***REMOVED***
        e = e + 1;
        f = 1;
      ***REMOVED***
      if (e > bias) ***REMOVED***
        // Overflow
        e = (1 << ebits) - 1;
        f = 0;
      ***REMOVED*** else ***REMOVED***
        // Normalized
        e = e + bias;
        f = f - pow(2, fbits);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      // Denormalized
      e = 0;
      f = roundToEven(v / pow(2, 1 - bias - fbits));
    ***REMOVED***
  ***REMOVED***

  // Pack sign, exponent, fraction
  bits = [];
  for (i = fbits; i; i -= 1) ***REMOVED*** bits.push(f % 2 ? 1 : 0); f = floor(f / 2); ***REMOVED***
  for (i = ebits; i; i -= 1) ***REMOVED*** bits.push(e % 2 ? 1 : 0); e = floor(e / 2); ***REMOVED***
  bits.push(s ? 1 : 0);
  bits.reverse();
  str = bits.join('');

  // Bits to bytes
  bytes = [];
  while (str.length) ***REMOVED***
    bytes.push(parseInt(str.substring(0, 8), 2));
    str = str.substring(8);
  ***REMOVED***
  return bytes;
***REMOVED***

function unpackIEEE754(bytes, ebits, fbits) ***REMOVED***

  // Bytes to bits
  var bits = [], i, j, b, str,
      bias, s, e, f;

  for (i = bytes.length; i; i -= 1) ***REMOVED***
    b = bytes[i - 1];
    for (j = 8; j; j -= 1) ***REMOVED***
      bits.push(b % 2 ? 1 : 0); b = b >> 1;
    ***REMOVED***
  ***REMOVED***
  bits.reverse();
  str = bits.join('');

  // Unpack sign, exponent, fraction
  bias = (1 << (ebits - 1)) - 1;
  s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
  e = parseInt(str.substring(1, 1 + ebits), 2);
  f = parseInt(str.substring(1 + ebits), 2);

  // Produce number
  if (e === (1 << ebits) - 1) ***REMOVED***
    return f !== 0 ? NaN : s * Infinity;
  ***REMOVED*** else if (e > 0) ***REMOVED***
    // Normalized
    return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
  ***REMOVED*** else if (f !== 0) ***REMOVED***
    // Denormalized
    return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
  ***REMOVED*** else ***REMOVED***
    return s < 0 ? -0 : 0;
  ***REMOVED***
***REMOVED***

function unpackF64(b) ***REMOVED*** return unpackIEEE754(b, 11, 52); ***REMOVED***
function packF64(v) ***REMOVED*** return packIEEE754(v, 11, 52); ***REMOVED***
function unpackF32(b) ***REMOVED*** return unpackIEEE754(b, 8, 23); ***REMOVED***
function packF32(v) ***REMOVED*** return packIEEE754(v, 8, 23); ***REMOVED***


//
// 3 The ArrayBuffer Type
//

(function() ***REMOVED***

  /** @constructor */
  var ArrayBuffer = function ArrayBuffer(length) ***REMOVED***
    length = ECMAScript.ToInt32(length);
    if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');

    this.byteLength = length;
    this._bytes = [];
    this._bytes.length = length;

    var i;
    for (i = 0; i < this.byteLength; i += 1) ***REMOVED***
      this._bytes[i] = 0;
    ***REMOVED***

    configureProperties(this);
  ***REMOVED***;

  exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;

  //
  // 4 The ArrayBufferView Type
  //

  // NOTE: this constructor is not exported
  /** @constructor */
  var ArrayBufferView = function ArrayBufferView() ***REMOVED***
    //this.buffer = null;
    //this.byteOffset = 0;
    //this.byteLength = 0;
  ***REMOVED***;

  //
  // 5 The Typed Array View Types
  //

  function makeConstructor(bytesPerElement, pack, unpack) ***REMOVED***
    // Each TypedArray type requires a distinct constructor instance with
    // identical logic, which this produces.

    var ctor;
    ctor = function(buffer, byteOffset, length) ***REMOVED***
      var array, sequence, i, s;

      if (!arguments.length || typeof arguments[0] === 'number') ***REMOVED***
        // Constructor(unsigned long length)
        this.length = ECMAScript.ToInt32(arguments[0]);
        if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');

        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        this.buffer = new ArrayBuffer(this.byteLength);
        this.byteOffset = 0;
      ***REMOVED*** else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) ***REMOVED***
        // Constructor(TypedArray array)
        array = arguments[0];

        this.length = array.length;
        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        this.buffer = new ArrayBuffer(this.byteLength);
        this.byteOffset = 0;

        for (i = 0; i < this.length; i += 1) ***REMOVED***
          this._setter(i, array._getter(i));
        ***REMOVED***
      ***REMOVED*** else if (typeof arguments[0] === 'object' &&
                 !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) ***REMOVED***
        // Constructor(sequence<type> array)
        sequence = arguments[0];

        this.length = ECMAScript.ToUint32(sequence.length);
        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        this.buffer = new ArrayBuffer(this.byteLength);
        this.byteOffset = 0;

        for (i = 0; i < this.length; i += 1) ***REMOVED***
          s = sequence[i];
          this._setter(i, Number(s));
        ***REMOVED***
      ***REMOVED*** else if (typeof arguments[0] === 'object' &&
                 (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) ***REMOVED***
        // Constructor(ArrayBuffer buffer,
        //             optional unsigned long byteOffset, optional unsigned long length)
        this.buffer = buffer;

        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) ***REMOVED***
          throw new RangeError("byteOffset out of range");
        ***REMOVED***

        if (this.byteOffset % this.BYTES_PER_ELEMENT) ***REMOVED***
          // The given byteOffset must be a multiple of the element
          // size of the specific type, otherwise an exception is raised.
          throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
        ***REMOVED***

        if (arguments.length < 3) ***REMOVED***
          this.byteLength = this.buffer.byteLength - this.byteOffset;

          if (this.byteLength % this.BYTES_PER_ELEMENT) ***REMOVED***
            throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
          ***REMOVED***
          this.length = this.byteLength / this.BYTES_PER_ELEMENT;
        ***REMOVED*** else ***REMOVED***
          this.length = ECMAScript.ToUint32(length);
          this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        ***REMOVED***

        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) ***REMOVED***
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        throw new TypeError("Unexpected argument type(s)");
      ***REMOVED***

      this.constructor = ctor;

      configureProperties(this);
      makeArrayAccessors(this);
    ***REMOVED***;

    ctor.prototype = new ArrayBufferView();
    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
    ctor.prototype._pack = pack;
    ctor.prototype._unpack = unpack;
    ctor.BYTES_PER_ELEMENT = bytesPerElement;

    // getter type (unsigned long index);
    ctor.prototype._getter = function(index) ***REMOVED***
      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");

      index = ECMAScript.ToUint32(index);
      if (index >= this.length) ***REMOVED***
        return undefined;
      ***REMOVED***

      var bytes = [], i, o;
      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
           i < this.BYTES_PER_ELEMENT;
           i += 1, o += 1) ***REMOVED***
        bytes.push(this.buffer._bytes[o]);
      ***REMOVED***
      return this._unpack(bytes);
    ***REMOVED***;

    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);
    ctor.prototype.get = ctor.prototype._getter;

    // setter void (unsigned long index, type value);
    ctor.prototype._setter = function(index, value) ***REMOVED***
      if (arguments.length < 2) throw new SyntaxError("Not enough arguments");

      index = ECMAScript.ToUint32(index);
      if (index >= this.length) ***REMOVED***
        return undefined;
      ***REMOVED***

      var bytes = this._pack(value), i, o;
      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
           i < this.BYTES_PER_ELEMENT;
           i += 1, o += 1) ***REMOVED***
        this.buffer._bytes[o] = bytes[i];
      ***REMOVED***
    ***REMOVED***;

    // void set(TypedArray array, optional unsigned long offset);
    // void set(sequence<type> array, optional unsigned long offset);
    ctor.prototype.set = function(index, value) ***REMOVED***
      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
      var array, sequence, offset, len,
          i, s, d,
          byteOffset, byteLength, tmp;

      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) ***REMOVED***
        // void set(TypedArray array, optional unsigned long offset);
        array = arguments[0];
        offset = ECMAScript.ToUint32(arguments[1]);

        if (offset + array.length > this.length) ***REMOVED***
          throw new RangeError("Offset plus length of array is out of range");
        ***REMOVED***

        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
        byteLength = array.length * this.BYTES_PER_ELEMENT;

        if (array.buffer === this.buffer) ***REMOVED***
          tmp = [];
          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) ***REMOVED***
            tmp[i] = array.buffer._bytes[s];
          ***REMOVED***
          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) ***REMOVED***
            this.buffer._bytes[d] = tmp[i];
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          for (i = 0, s = array.byteOffset, d = byteOffset;
               i < byteLength; i += 1, s += 1, d += 1) ***REMOVED***
            this.buffer._bytes[d] = array.buffer._bytes[s];
          ***REMOVED***
        ***REMOVED***
      ***REMOVED*** else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') ***REMOVED***
        // void set(sequence<type> array, optional unsigned long offset);
        sequence = arguments[0];
        len = ECMAScript.ToUint32(sequence.length);
        offset = ECMAScript.ToUint32(arguments[1]);

        if (offset + len > this.length) ***REMOVED***
          throw new RangeError("Offset plus length of array is out of range");
        ***REMOVED***

        for (i = 0; i < len; i += 1) ***REMOVED***
          s = sequence[i];
          this._setter(offset + i, Number(s));
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        throw new TypeError("Unexpected argument type(s)");
      ***REMOVED***
    ***REMOVED***;

    // TypedArray subarray(long begin, optional long end);
    ctor.prototype.subarray = function(start, end) ***REMOVED***
      function clamp(v, min, max) ***REMOVED*** return v < min ? min : v > max ? max : v; ***REMOVED***

      start = ECMAScript.ToInt32(start);
      end = ECMAScript.ToInt32(end);

      if (arguments.length < 1) ***REMOVED*** start = 0; ***REMOVED***
      if (arguments.length < 2) ***REMOVED*** end = this.length; ***REMOVED***

      if (start < 0) ***REMOVED*** start = this.length + start; ***REMOVED***
      if (end < 0) ***REMOVED*** end = this.length + end; ***REMOVED***

      start = clamp(start, 0, this.length);
      end = clamp(end, 0, this.length);

      var len = end - start;
      if (len < 0) ***REMOVED***
        len = 0;
      ***REMOVED***

      return new this.constructor(
        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
    ***REMOVED***;

    return ctor;
  ***REMOVED***

  var Int8Array = makeConstructor(1, packI8, unpackI8);
  var Uint8Array = makeConstructor(1, packU8, unpackU8);
  var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
  var Int16Array = makeConstructor(2, packI16, unpackI16);
  var Uint16Array = makeConstructor(2, packU16, unpackU16);
  var Int32Array = makeConstructor(4, packI32, unpackI32);
  var Uint32Array = makeConstructor(4, packU32, unpackU32);
  var Float32Array = makeConstructor(4, packF32, unpackF32);
  var Float64Array = makeConstructor(8, packF64, unpackF64);

  exports.Int8Array = exports.Int8Array || Int8Array;
  exports.Uint8Array = exports.Uint8Array || Uint8Array;
  exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
  exports.Int16Array = exports.Int16Array || Int16Array;
  exports.Uint16Array = exports.Uint16Array || Uint16Array;
  exports.Int32Array = exports.Int32Array || Int32Array;
  exports.Uint32Array = exports.Uint32Array || Uint32Array;
  exports.Float32Array = exports.Float32Array || Float32Array;
  exports.Float64Array = exports.Float64Array || Float64Array;
***REMOVED***());

//
// 6 The DataView View Type
//

(function() ***REMOVED***
  function r(array, index) ***REMOVED***
    return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
  ***REMOVED***

  var IS_BIG_ENDIAN = (function() ***REMOVED***
    var u16array = new(exports.Uint16Array)([0x1234]),
        u8array = new(exports.Uint8Array)(u16array.buffer);
    return r(u8array, 0) === 0x12;
  ***REMOVED***());

  // Constructor(ArrayBuffer buffer,
  //             optional unsigned long byteOffset,
  //             optional unsigned long byteLength)
  /** @constructor */
  var DataView = function DataView(buffer, byteOffset, byteLength) ***REMOVED***
    if (arguments.length === 0) ***REMOVED***
      buffer = new exports.ArrayBuffer(0);
    ***REMOVED*** else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) ***REMOVED***
      throw new TypeError("TypeError");
    ***REMOVED***

    this.buffer = buffer || new exports.ArrayBuffer(0);

    this.byteOffset = ECMAScript.ToUint32(byteOffset);
    if (this.byteOffset > this.buffer.byteLength) ***REMOVED***
      throw new RangeError("byteOffset out of range");
    ***REMOVED***

    if (arguments.length < 3) ***REMOVED***
      this.byteLength = this.buffer.byteLength - this.byteOffset;
    ***REMOVED*** else ***REMOVED***
      this.byteLength = ECMAScript.ToUint32(byteLength);
    ***REMOVED***

    if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) ***REMOVED***
      throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
    ***REMOVED***

    configureProperties(this);
  ***REMOVED***;

  function makeGetter(arrayType) ***REMOVED***
    return function(byteOffset, littleEndian) ***REMOVED***

      byteOffset = ECMAScript.ToUint32(byteOffset);

      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) ***REMOVED***
        throw new RangeError("Array index out of range");
      ***REMOVED***
      byteOffset += this.byteOffset;

      var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
          bytes = [], i;
      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) ***REMOVED***
        bytes.push(r(uint8Array, i));
      ***REMOVED***

      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) ***REMOVED***
        bytes.reverse();
      ***REMOVED***

      return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
    ***REMOVED***;
  ***REMOVED***

  DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
  DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
  DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
  DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
  DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
  DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
  DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
  DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);

  function makeSetter(arrayType) ***REMOVED***
    return function(byteOffset, value, littleEndian) ***REMOVED***

      byteOffset = ECMAScript.ToUint32(byteOffset);
      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) ***REMOVED***
        throw new RangeError("Array index out of range");
      ***REMOVED***

      // Get bytes
      var typeArray = new arrayType([value]),
          byteArray = new exports.Uint8Array(typeArray.buffer),
          bytes = [], i, byteView;

      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) ***REMOVED***
        bytes.push(r(byteArray, i));
      ***REMOVED***

      // Flip if necessary
      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) ***REMOVED***
        bytes.reverse();
      ***REMOVED***

      // Write them
      byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
      byteView.set(bytes);
    ***REMOVED***;
  ***REMOVED***

  DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
  DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
  DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
  DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
  DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
  DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
  DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
  DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);

  exports.DataView = exports.DataView || DataView;

***REMOVED***());
