/*********************************************************************
 * NAN - Native Abstractions for Node.js
 *
 * Copyright (c) 2017 NAN contributors:
 *   - Rod Vagg <https://github.com/rvagg>
 *   - Benjamin Byholm <https://github.com/kkoopa>
 *   - Trevor Norris <https://github.com/trevnorris>
 *   - Nathan Rajlich <https://github.com/TooTallNate>
 *   - Brett Lawson <https://github.com/brett19>
 *   - Ben Noordhuis <https://github.com/bnoordhuis>
 *   - David Siegel <https://github.com/agnat>
 *   - Michael Ira Krufky <https://github.com/mkrufky>
 *
 * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>
 *
 * Version 2.8.0: current Node 9.2.0, Node 12: 0.12.18, Node 10: 0.10.48, iojs: 3.3.1
 *
 * See https://github.com/nodejs/nan for the latest update to this file
 **********************************************************************************/

#ifndef NAN_H_
#define NAN_H_

#include <node_version.h>

#define NODE_0_10_MODULE_VERSION 11
#define NODE_0_12_MODULE_VERSION 14
#define ATOM_0_21_MODULE_VERSION 41
#define IOJS_1_0_MODULE_VERSION  42
#define IOJS_1_1_MODULE_VERSION  43
#define IOJS_2_0_MODULE_VERSION  44
#define IOJS_3_0_MODULE_VERSION  45
#define NODE_4_0_MODULE_VERSION  46
#define NODE_5_0_MODULE_VERSION  47
#define NODE_6_0_MODULE_VERSION  48
#define NODE_7_0_MODULE_VERSION  51
#define NODE_8_0_MODULE_VERSION  57
#define NODE_9_0_MODULE_VERSION  59

#ifdef _MSC_VER
# define NAN_HAS_CPLUSPLUS_11 (_MSC_VER >= 1800)
#else
# define NAN_HAS_CPLUSPLUS_11 (__cplusplus >= 201103L)
#endif

#if NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION && !NAN_HAS_CPLUSPLUS_11
# error This version of node/NAN/v8 requires a C++11 compiler
#endif

#include <uv.h>
#include <node.h>
#include <node_buffer.h>
#include <node_object_wrap.h>
#include <algorithm>
#include <cstring>
#include <climits>
#include <cstdlib>
#include <utility>
#if defined(_MSC_VER)
# pragma warning( push )
# pragma warning( disable : 4530 )
# include <queue>
# include <string>
# include <vector>
# pragma warning( pop )
#else
# include <queue>
# include <string>
# include <vector>
#endif

// uv helpers
#ifdef UV_VERSION_MAJOR
# ifndef UV_VERSION_PATCH
#  define UV_VERSION_PATCH 0
# endif
# define NAUV_UVVERSION ((UV_VERSION_MAJOR << 16) | \
                         (UV_VERSION_MINOR <<  8) | \
                         (UV_VERSION_PATCH))
#else
# define NAUV_UVVERSION 0x000b00
#endif

#if NAUV_UVVERSION < 0x000b0b
# ifdef WIN32
#  include <windows.h>
# else
#  include <pthread.h>
# endif
#endif

namespace Nan ***REMOVED***

#define NAN_INLINE inline  // TODO(bnoordhuis) Remove in v3.0.0.

#if defined(__GNUC__) && \
    !(defined(V8_DISABLE_DEPRECATIONS) && V8_DISABLE_DEPRECATIONS)
# define NAN_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER) && \
    !(defined(V8_DISABLE_DEPRECATIONS) && V8_DISABLE_DEPRECATIONS)
# define NAN_DEPRECATED __declspec(deprecated)
#else
# define NAN_DEPRECATED
#endif

#if NAN_HAS_CPLUSPLUS_11
# define NAN_DISALLOW_ASSIGN(CLASS) void operator=(const CLASS&) = delete;
# define NAN_DISALLOW_COPY(CLASS) CLASS(const CLASS&) = delete;
# define NAN_DISALLOW_MOVE(CLASS)                                              \
    CLASS(CLASS&&) = delete;  /* NOLINT(build/c++11) */                        \
    void operator=(CLASS&&) = delete;
#else
# define NAN_DISALLOW_ASSIGN(CLASS) void operator=(const CLASS&);
# define NAN_DISALLOW_COPY(CLASS) CLASS(const CLASS&);
# define NAN_DISALLOW_MOVE(CLASS)
#endif

#define NAN_DISALLOW_ASSIGN_COPY(CLASS)                                        \
    NAN_DISALLOW_ASSIGN(CLASS)                                                 \
    NAN_DISALLOW_COPY(CLASS)

#define NAN_DISALLOW_ASSIGN_MOVE(CLASS)                                        \
    NAN_DISALLOW_ASSIGN(CLASS)                                                 \
    NAN_DISALLOW_MOVE(CLASS)

#define NAN_DISALLOW_COPY_MOVE(CLASS)                                          \
    NAN_DISALLOW_COPY(CLASS)                                                   \
    NAN_DISALLOW_MOVE(CLASS)

#define NAN_DISALLOW_ASSIGN_COPY_MOVE(CLASS)                                   \
    NAN_DISALLOW_ASSIGN(CLASS)                                                 \
    NAN_DISALLOW_COPY(CLASS)                                                   \
    NAN_DISALLOW_MOVE(CLASS)

#define TYPE_CHECK(T, S)                                                       \
    while (false) ***REMOVED***                                                            \
      *(static_cast<T *volatile *>(0)) = static_cast<S*>(0);                   \
    ***REMOVED***

//=== RegistrationFunction =====================================================

#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION
  typedef v8::Handle<v8::Object> ADDON_REGISTER_FUNCTION_ARGS_TYPE;
#else
  typedef v8::Local<v8::Object> ADDON_REGISTER_FUNCTION_ARGS_TYPE;
#endif

#define NAN_MODULE_INIT(name)                                                  \
    void name(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target)

//=== CallbackInfo =============================================================

#include "nan_callbacks.h"  // NOLINT(build/include)

//==============================================================================

#if (NODE_MODULE_VERSION < NODE_0_12_MODULE_VERSION)
typedef v8::Script             UnboundScript;
typedef v8::Script             BoundScript;
#else
typedef v8::UnboundScript      UnboundScript;
typedef v8::Script             BoundScript;
#endif

#if (NODE_MODULE_VERSION < ATOM_0_21_MODULE_VERSION)
typedef v8::String::ExternalAsciiStringResource
    ExternalOneByteStringResource;
#else
typedef v8::String::ExternalOneByteStringResource
    ExternalOneByteStringResource;
#endif

#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
template<typename T>
class NonCopyablePersistentTraits :
    public v8::NonCopyablePersistentTraits<T> ***REMOVED******REMOVED***;
template<typename T>
class CopyablePersistentTraits :
    public v8::CopyablePersistentTraits<T> ***REMOVED******REMOVED***;

template<typename T>
class PersistentBase :
    public v8::PersistentBase<T> ***REMOVED******REMOVED***;

template<typename T, typename M = v8::NonCopyablePersistentTraits<T> >
class Persistent;
#else
template<typename T> class NonCopyablePersistentTraits;
template<typename T> class PersistentBase;
template<typename T, typename P> class WeakCallbackData;
template<typename T, typename M = NonCopyablePersistentTraits<T> >
class Persistent;
#endif  // NODE_MODULE_VERSION

#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \
  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))
# include "nan_maybe_43_inl.h"  // NOLINT(build/include)
#else
# include "nan_maybe_pre_43_inl.h"  // NOLINT(build/include)
#endif

#include "nan_converters.h"  // NOLINT(build/include)
#include "nan_new.h"  // NOLINT(build/include)

#if NAUV_UVVERSION < 0x000b17
#define NAUV_WORK_CB(func) \
    void func(uv_async_t *async, int)
#else
#define NAUV_WORK_CB(func) \
    void func(uv_async_t *async)
#endif

#if NAUV_UVVERSION >= 0x000b0b

typedef uv_key_t nauv_key_t;

inline int nauv_key_create(nauv_key_t *key) ***REMOVED***
  return uv_key_create(key);
***REMOVED***

inline void nauv_key_delete(nauv_key_t *key) ***REMOVED***
  uv_key_delete(key);
***REMOVED***

inline void* nauv_key_get(nauv_key_t *key) ***REMOVED***
  return uv_key_get(key);
***REMOVED***

inline void nauv_key_set(nauv_key_t *key, void *value) ***REMOVED***
  uv_key_set(key, value);
***REMOVED***

#else

/* Implement thread local storage for older versions of libuv.
 * This is essentially a backport of libuv commit 5d2434bf
 * written by Ben Noordhuis, adjusted for names and inline.
 */

#ifndef WIN32

typedef pthread_key_t nauv_key_t;

inline int nauv_key_create(nauv_key_t* key) ***REMOVED***
  return -pthread_key_create(key, NULL);
***REMOVED***

inline void nauv_key_delete(nauv_key_t* key) ***REMOVED***
  if (pthread_key_delete(*key))
    abort();
***REMOVED***

inline void* nauv_key_get(nauv_key_t* key) ***REMOVED***
  return pthread_getspecific(*key);
***REMOVED***

inline void nauv_key_set(nauv_key_t* key, void* value) ***REMOVED***
  if (pthread_setspecific(*key, value))
    abort();
***REMOVED***

#else

typedef struct ***REMOVED***
  DWORD tls_index;
***REMOVED*** nauv_key_t;

inline int nauv_key_create(nauv_key_t* key) ***REMOVED***
  key->tls_index = TlsAlloc();
  if (key->tls_index == TLS_OUT_OF_INDEXES)
    return UV_ENOMEM;
  return 0;
***REMOVED***

inline void nauv_key_delete(nauv_key_t* key) ***REMOVED***
  if (TlsFree(key->tls_index) == FALSE)
    abort();
  key->tls_index = TLS_OUT_OF_INDEXES;
***REMOVED***

inline void* nauv_key_get(nauv_key_t* key) ***REMOVED***
  void* value = TlsGetValue(key->tls_index);
  if (value == NULL)
    if (GetLastError() != ERROR_SUCCESS)
      abort();
  return value;
***REMOVED***

inline void nauv_key_set(nauv_key_t* key, void* value) ***REMOVED***
  if (TlsSetValue(key->tls_index, value) == FALSE)
    abort();
***REMOVED***

#endif
#endif

#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION
template<typename T>
v8::Local<T> New(v8::Handle<T>);
#endif

#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \
  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))
  typedef v8::WeakCallbackType WeakCallbackType;
#else
struct WeakCallbackType ***REMOVED***
  enum E ***REMOVED***kParameter, kInternalFields***REMOVED***;
  E type;
  WeakCallbackType(E other) : type(other) ***REMOVED******REMOVED***  // NOLINT(runtime/explicit)
  inline bool operator==(E other) ***REMOVED*** return other == this->type; ***REMOVED***
  inline bool operator!=(E other) ***REMOVED*** return !operator==(other); ***REMOVED***
***REMOVED***;
#endif

template<typename P> class WeakCallbackInfo;

#if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION
# include "nan_persistent_12_inl.h"  // NOLINT(build/include)
#else
# include "nan_persistent_pre_12_inl.h"  // NOLINT(build/include)
#endif

namespace imp ***REMOVED***
  static const size_t kMaxLength = 0x3fffffff;
  // v8::String::REPLACE_INVALID_UTF8 was introduced
  // in node.js v0.10.29 and v0.8.27.
#if NODE_MAJOR_VERSION > 0 || \
    NODE_MINOR_VERSION > 10 || \
    NODE_MINOR_VERSION == 10 && NODE_PATCH_VERSION >= 29 || \
    NODE_MINOR_VERSION == 8 && NODE_PATCH_VERSION >= 27
  static const unsigned kReplaceInvalidUtf8 = v8::String::REPLACE_INVALID_UTF8;
#else
  static const unsigned kReplaceInvalidUtf8 = 0;
#endif
***REMOVED***  // end of namespace imp

//=== HandleScope ==============================================================

class HandleScope ***REMOVED***
  v8::HandleScope scope;

 public:
#if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION
  inline HandleScope() : scope(v8::Isolate::GetCurrent()) ***REMOVED******REMOVED***
  inline static int NumberOfHandles() ***REMOVED***
    return v8::HandleScope::NumberOfHandles(v8::Isolate::GetCurrent());
  ***REMOVED***
#else
  inline HandleScope() : scope() ***REMOVED******REMOVED***
  inline static int NumberOfHandles() ***REMOVED***
    return v8::HandleScope::NumberOfHandles();
  ***REMOVED***
#endif

 private:
  // Make it hard to create heap-allocated or illegal handle scopes by
  // disallowing certain operations.
  HandleScope(const HandleScope &);
  void operator=(const HandleScope &);
  void *operator new(size_t size);
  void operator delete(void *, size_t) ***REMOVED***
    abort();
  ***REMOVED***
***REMOVED***;

class EscapableHandleScope ***REMOVED***
 public:
#if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION
  inline EscapableHandleScope() : scope(v8::Isolate::GetCurrent()) ***REMOVED******REMOVED***

  inline static int NumberOfHandles() ***REMOVED***
    return v8::EscapableHandleScope::NumberOfHandles(v8::Isolate::GetCurrent());
  ***REMOVED***

  template<typename T>
  inline v8::Local<T> Escape(v8::Local<T> value) ***REMOVED***
    return scope.Escape(value);
  ***REMOVED***

 private:
  v8::EscapableHandleScope scope;
#else
  inline EscapableHandleScope() : scope() ***REMOVED******REMOVED***

  inline static int NumberOfHandles() ***REMOVED***
    return v8::HandleScope::NumberOfHandles();
  ***REMOVED***

  template<typename T>
  inline v8::Local<T> Escape(v8::Local<T> value) ***REMOVED***
    return scope.Close(value);
  ***REMOVED***

 private:
  v8::HandleScope scope;
#endif

 private:
  // Make it hard to create heap-allocated or illegal handle scopes by
  // disallowing certain operations.
  EscapableHandleScope(const EscapableHandleScope &);
  void operator=(const EscapableHandleScope &);
  void *operator new(size_t size);
  void operator delete(void *, size_t) ***REMOVED***
    abort();
  ***REMOVED***
***REMOVED***;

//=== TryCatch =================================================================

class TryCatch ***REMOVED***
  v8::TryCatch try_catch_;
  friend void FatalException(const TryCatch&);

 public:
#if NODE_MODULE_VERSION > NODE_0_12_MODULE_VERSION
  TryCatch() : try_catch_(v8::Isolate::GetCurrent()) ***REMOVED******REMOVED***
#endif

  inline bool HasCaught() const ***REMOVED*** return try_catch_.HasCaught(); ***REMOVED***

  inline bool CanContinue() const ***REMOVED*** return try_catch_.CanContinue(); ***REMOVED***

  inline v8::Local<v8::Value> ReThrow() ***REMOVED***
#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION
    return New(try_catch_.ReThrow());
#else
    return try_catch_.ReThrow();
#endif
  ***REMOVED***

  inline v8::Local<v8::Value> Exception() const ***REMOVED***
    return try_catch_.Exception();
  ***REMOVED***

#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \
  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))
  inline v8::MaybeLocal<v8::Value> StackTrace() const ***REMOVED***
    v8::Isolate *isolate = v8::Isolate::GetCurrent();
    v8::EscapableHandleScope scope(isolate);
    return scope.Escape(try_catch_.StackTrace(isolate->GetCurrentContext())
                            .FromMaybe(v8::Local<v8::Value>()));
  ***REMOVED***
#else
  inline MaybeLocal<v8::Value> StackTrace() const ***REMOVED***
    return try_catch_.StackTrace();
  ***REMOVED***
#endif

  inline v8::Local<v8::Message> Message() const ***REMOVED***
    return try_catch_.Message();
  ***REMOVED***

  inline void Reset() ***REMOVED*** try_catch_.Reset(); ***REMOVED***

  inline void SetVerbose(bool value) ***REMOVED*** try_catch_.SetVerbose(value); ***REMOVED***

  inline void SetCaptureMessage(bool value) ***REMOVED***
    try_catch_.SetCaptureMessage(value);
  ***REMOVED***
***REMOVED***;

//============ =================================================================

/* node 0.12  */
#if NODE_MODULE_VERSION >= NODE_0_12_MODULE_VERSION
  inline
  void SetCounterFunction(v8::CounterLookupCallback cb) ***REMOVED***
    v8::Isolate::GetCurrent()->SetCounterFunction(cb);
  ***REMOVED***

  inline
  void SetCreateHistogramFunction(v8::CreateHistogramCallback cb) ***REMOVED***
    v8::Isolate::GetCurrent()->SetCreateHistogramFunction(cb);
  ***REMOVED***

  inline
  void SetAddHistogramSampleFunction(v8::AddHistogramSampleCallback cb) ***REMOVED***
    v8::Isolate::GetCurrent()->SetAddHistogramSampleFunction(cb);
  ***REMOVED***

#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \
  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))
  inline bool IdleNotification(int idle_time_in_ms) ***REMOVED***
    return v8::Isolate::GetCurrent()->IdleNotificationDeadline(
        idle_time_in_ms * 0.001);
  ***REMOVED***
# else
  inline bool IdleNotification(int idle_time_in_ms) ***REMOVED***
    return v8::Isolate::GetCurrent()->IdleNotification(idle_time_in_ms);
  ***REMOVED***
#endif

  inline void LowMemoryNotification() ***REMOVED***
    v8::Isolate::GetCurrent()->LowMemoryNotification();
  ***REMOVED***

  inline void ContextDisposedNotification() ***REMOVED***
    v8::Isolate::GetCurrent()->ContextDisposedNotification();
  ***REMOVED***
#else
  inline
  void SetCounterFunction(v8::CounterLookupCallback cb) ***REMOVED***
    v8::V8::SetCounterFunction(cb);
  ***REMOVED***

  inline
  void SetCreateHistogramFunction(v8::CreateHistogramCallback cb) ***REMOVED***
    v8::V8::SetCreateHistogramFunction(cb);
  ***REMOVED***

  inline
  void SetAddHistogramSampleFunction(v8::AddHistogramSampleCallback cb) ***REMOVED***
    v8::V8::SetAddHistogramSampleFunction(cb);
  ***REMOVED***

  inline bool IdleNotification(int idle_time_in_ms) ***REMOVED***
    return v8::V8::IdleNotification(idle_time_in_ms);
  ***REMOVED***

  inline void LowMemoryNotification() ***REMOVED***
    v8::V8::LowMemoryNotification();
  ***REMOVED***

  inline void ContextDisposedNotification() ***REMOVED***
    v8::V8::ContextDisposedNotification();
  ***REMOVED***
#endif

#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)  // Node 0.12
  inline v8::Local<v8::Primitive> Undefined() ***REMOVED***
# if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION
    EscapableHandleScope scope;
    return scope.Escape(New(v8::Undefined(v8::Isolate::GetCurrent())));
# else
    return v8::Undefined(v8::Isolate::GetCurrent());
# endif
  ***REMOVED***

  inline v8::Local<v8::Primitive> Null() ***REMOVED***
# if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION
    EscapableHandleScope scope;
    return scope.Escape(New(v8::Null(v8::Isolate::GetCurrent())));
# else
    return v8::Null(v8::Isolate::GetCurrent());
# endif
  ***REMOVED***

  inline v8::Local<v8::Boolean> True() ***REMOVED***
# if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION
    EscapableHandleScope scope;
    return scope.Escape(New(v8::True(v8::Isolate::GetCurrent())));
# else
    return v8::True(v8::Isolate::GetCurrent());
# endif
  ***REMOVED***

  inline v8::Local<v8::Boolean> False() ***REMOVED***
# if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION
    EscapableHandleScope scope;
    return scope.Escape(New(v8::False(v8::Isolate::GetCurrent())));
# else
    return v8::False(v8::Isolate::GetCurrent());
# endif
  ***REMOVED***

  inline v8::Local<v8::String> EmptyString() ***REMOVED***
    return v8::String::Empty(v8::Isolate::GetCurrent());
  ***REMOVED***

  inline int AdjustExternalMemory(int bc) ***REMOVED***
    return static_cast<int>(
        v8::Isolate::GetCurrent()->AdjustAmountOfExternalAllocatedMemory(bc));
  ***REMOVED***

  inline void SetTemplate(
      v8::Local<v8::Template> templ
    , const char *name
    , v8::Local<v8::Data> value) ***REMOVED***
    templ->Set(v8::Isolate::GetCurrent(), name, value);
  ***REMOVED***

  inline void SetTemplate(
      v8::Local<v8::Template> templ
    , v8::Local<v8::String> name
    , v8::Local<v8::Data> value
    , v8::PropertyAttribute attributes) ***REMOVED***
    templ->Set(name, value, attributes);
  ***REMOVED***

  inline v8::Local<v8::Context> GetCurrentContext() ***REMOVED***
    return v8::Isolate::GetCurrent()->GetCurrentContext();
  ***REMOVED***

  inline void* GetInternalFieldPointer(
      v8::Local<v8::Object> object
    , int index) ***REMOVED***
    return object->GetAlignedPointerFromInternalField(index);
  ***REMOVED***

  inline void SetInternalFieldPointer(
      v8::Local<v8::Object> object
    , int index
    , void* value) ***REMOVED***
    object->SetAlignedPointerInInternalField(index, value);
  ***REMOVED***

# define NAN_GC_CALLBACK(name)                                                 \
    void name(v8::Isolate *isolate, v8::GCType type, v8::GCCallbackFlags flags)

#if NODE_MODULE_VERSION <= NODE_4_0_MODULE_VERSION
  typedef v8::Isolate::GCEpilogueCallback GCEpilogueCallback;
  typedef v8::Isolate::GCPrologueCallback GCPrologueCallback;
#else
  typedef v8::Isolate::GCCallback GCEpilogueCallback;
  typedef v8::Isolate::GCCallback GCPrologueCallback;
#endif

  inline void AddGCEpilogueCallback(
      GCEpilogueCallback callback
    , v8::GCType gc_type_filter = v8::kGCTypeAll) ***REMOVED***
    v8::Isolate::GetCurrent()->AddGCEpilogueCallback(callback, gc_type_filter);
  ***REMOVED***

  inline void RemoveGCEpilogueCallback(
      GCEpilogueCallback callback) ***REMOVED***
    v8::Isolate::GetCurrent()->RemoveGCEpilogueCallback(callback);
  ***REMOVED***

  inline void AddGCPrologueCallback(
      GCPrologueCallback callback
    , v8::GCType gc_type_filter = v8::kGCTypeAll) ***REMOVED***
    v8::Isolate::GetCurrent()->AddGCPrologueCallback(callback, gc_type_filter);
  ***REMOVED***

  inline void RemoveGCPrologueCallback(
      GCPrologueCallback callback) ***REMOVED***
    v8::Isolate::GetCurrent()->RemoveGCPrologueCallback(callback);
  ***REMOVED***

  inline void GetHeapStatistics(
      v8::HeapStatistics *heap_statistics) ***REMOVED***
    v8::Isolate::GetCurrent()->GetHeapStatistics(heap_statistics);
  ***REMOVED***

# define X(NAME)                                                               \
    inline v8::Local<v8::Value> NAME(const char *msg) ***REMOVED***                        \
      EscapableHandleScope scope;                                              \
      return scope.Escape(v8::Exception::NAME(New(msg).ToLocalChecked()));     \
    ***REMOVED***                                                                          \
                                                                               \
    inline                                                                     \
    v8::Local<v8::Value> NAME(v8::Local<v8::String> msg) ***REMOVED***                     \
      return v8::Exception::NAME(msg);                                         \
    ***REMOVED***                                                                          \
                                                                               \
    inline void Throw ## NAME(const char *msg) ***REMOVED***                               \
      HandleScope scope;                                                       \
      v8::Isolate::GetCurrent()->ThrowException(                               \
          v8::Exception::NAME(New(msg).ToLocalChecked()));                     \
    ***REMOVED***                                                                          \
                                                                               \
    inline void Throw ## NAME(v8::Local<v8::String> msg) ***REMOVED***                     \
      HandleScope scope;                                                       \
      v8::Isolate::GetCurrent()->ThrowException(                               \
          v8::Exception::NAME(msg));                                           \
    ***REMOVED***

  X(Error)
  X(RangeError)
  X(ReferenceError)
  X(SyntaxError)
  X(TypeError)

# undef X

  inline void ThrowError(v8::Local<v8::Value> error) ***REMOVED***
    v8::Isolate::GetCurrent()->ThrowException(error);
  ***REMOVED***

  inline MaybeLocal<v8::Object> NewBuffer(
      char *data
    , size_t length
#if NODE_MODULE_VERSION > IOJS_2_0_MODULE_VERSION
    , node::Buffer::FreeCallback callback
#else
    , node::smalloc::FreeCallback callback
#endif
    , void *hint
  ) ***REMOVED***
    // arbitrary buffer lengths requires
    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION
    assert(length <= imp::kMaxLength && "too large buffer");
#if NODE_MODULE_VERSION > IOJS_2_0_MODULE_VERSION
    return node::Buffer::New(
        v8::Isolate::GetCurrent(), data, length, callback, hint);
#else
    return node::Buffer::New(v8::Isolate::GetCurrent(), data, length, callback,
                             hint);
#endif
  ***REMOVED***

  inline MaybeLocal<v8::Object> CopyBuffer(
      const char *data
    , uint32_t size
  ) ***REMOVED***
    // arbitrary buffer lengths requires
    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION
    assert(size <= imp::kMaxLength && "too large buffer");
#if NODE_MODULE_VERSION > IOJS_2_0_MODULE_VERSION
    return node::Buffer::Copy(
        v8::Isolate::GetCurrent(), data, size);
#else
    return node::Buffer::New(v8::Isolate::GetCurrent(), data, size);
#endif
  ***REMOVED***

  inline MaybeLocal<v8::Object> NewBuffer(uint32_t size) ***REMOVED***
    // arbitrary buffer lengths requires
    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION
    assert(size <= imp::kMaxLength && "too large buffer");
#if NODE_MODULE_VERSION > IOJS_2_0_MODULE_VERSION
    return node::Buffer::New(
        v8::Isolate::GetCurrent(), size);
#else
    return node::Buffer::New(v8::Isolate::GetCurrent(), size);
#endif
  ***REMOVED***

  inline MaybeLocal<v8::Object> NewBuffer(
      char* data
    , uint32_t size
  ) ***REMOVED***
    // arbitrary buffer lengths requires
    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION
    assert(size <= imp::kMaxLength && "too large buffer");
#if NODE_MODULE_VERSION > IOJS_2_0_MODULE_VERSION
    return node::Buffer::New(v8::Isolate::GetCurrent(), data, size);
#else
    return node::Buffer::Use(v8::Isolate::GetCurrent(), data, size);
#endif
  ***REMOVED***

#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \
  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))
  inline MaybeLocal<v8::String>
  NewOneByteString(const uint8_t * value, int length = -1) ***REMOVED***
    return v8::String::NewFromOneByte(v8::Isolate::GetCurrent(), value,
          v8::NewStringType::kNormal, length);
  ***REMOVED***

  inline MaybeLocal<BoundScript> CompileScript(
      v8::Local<v8::String> s
    , const v8::ScriptOrigin& origin
  ) ***REMOVED***
    v8::Isolate *isolate = v8::Isolate::GetCurrent();
    v8::EscapableHandleScope scope(isolate);
    v8::ScriptCompiler::Source source(s, origin);
    return scope.Escape(
        v8::ScriptCompiler::Compile(isolate->GetCurrentContext(), &source)
            .FromMaybe(v8::Local<BoundScript>()));
  ***REMOVED***

  inline MaybeLocal<BoundScript> CompileScript(
      v8::Local<v8::String> s
  ) ***REMOVED***
    v8::Isolate *isolate = v8::Isolate::GetCurrent();
    v8::EscapableHandleScope scope(isolate);
    v8::ScriptCompiler::Source source(s);
    return scope.Escape(
        v8::ScriptCompiler::Compile(isolate->GetCurrentContext(), &source)
            .FromMaybe(v8::Local<BoundScript>()));
  ***REMOVED***

  inline MaybeLocal<v8::Value> RunScript(
      v8::Local<UnboundScript> script
  ) ***REMOVED***
    v8::Isolate *isolate = v8::Isolate::GetCurrent();
    v8::EscapableHandleScope scope(isolate);
    return scope.Escape(script->BindToCurrentContext()
                            ->Run(isolate->GetCurrentContext())
                            .FromMaybe(v8::Local<v8::Value>()));
  ***REMOVED***

  inline MaybeLocal<v8::Value> RunScript(
      v8::Local<BoundScript> script
  ) ***REMOVED***
    v8::Isolate *isolate = v8::Isolate::GetCurrent();
    v8::EscapableHandleScope scope(isolate);
    return scope.Escape(script->Run(isolate->GetCurrentContext())
                            .FromMaybe(v8::Local<v8::Value>()));
  ***REMOVED***
#else
  inline MaybeLocal<v8::String>
  NewOneByteString(const uint8_t * value, int length = -1) ***REMOVED***
    return v8::String::NewFromOneByte(v8::Isolate::GetCurrent(), value,
                                      v8::String::kNormalString, length);
  ***REMOVED***

  inline MaybeLocal<BoundScript> CompileScript(
      v8::Local<v8::String> s
    , const v8::ScriptOrigin& origin
  ) ***REMOVED***
    v8::ScriptCompiler::Source source(s, origin);
    return v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &source);
  ***REMOVED***

  inline MaybeLocal<BoundScript> CompileScript(
      v8::Local<v8::String> s
  ) ***REMOVED***
    v8::ScriptCompiler::Source source(s);
    return v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &source);
  ***REMOVED***

  inline MaybeLocal<v8::Value> RunScript(
      v8::Local<UnboundScript> script
  ) ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(script->BindToCurrentContext()->Run());
  ***REMOVED***

  inline MaybeLocal<v8::Value> RunScript(
      v8::Local<BoundScript> script
  ) ***REMOVED***
    return script->Run();
  ***REMOVED***
#endif

  inline v8::Local<v8::Value> MakeCallback(
      v8::Local<v8::Object> target
    , v8::Local<v8::Function> func
    , int argc
    , v8::Local<v8::Value>* argv) ***REMOVED***
#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION
    EscapableHandleScope scope;
    return scope.Escape(New(node::MakeCallback(
        v8::Isolate::GetCurrent(), target, func, argc, argv)));
#else
    return node::MakeCallback(
        v8::Isolate::GetCurrent(), target, func, argc, argv);
#endif
  ***REMOVED***

  inline v8::Local<v8::Value> MakeCallback(
      v8::Local<v8::Object> target
    , v8::Local<v8::String> symbol
    , int argc
    , v8::Local<v8::Value>* argv) ***REMOVED***
#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION
    EscapableHandleScope scope;
    return scope.Escape(New(node::MakeCallback(
        v8::Isolate::GetCurrent(), target, symbol, argc, argv)));
#else
    return node::MakeCallback(
        v8::Isolate::GetCurrent(), target, symbol, argc, argv);
#endif
  ***REMOVED***

  inline v8::Local<v8::Value> MakeCallback(
      v8::Local<v8::Object> target
    , const char* method
    , int argc
    , v8::Local<v8::Value>* argv) ***REMOVED***
#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION
    EscapableHandleScope scope;
    return scope.Escape(New(node::MakeCallback(
        v8::Isolate::GetCurrent(), target, method, argc, argv)));
#else
    return node::MakeCallback(
        v8::Isolate::GetCurrent(), target, method, argc, argv);
#endif
  ***REMOVED***

  inline void FatalException(const TryCatch& try_catch) ***REMOVED***
    node::FatalException(v8::Isolate::GetCurrent(), try_catch.try_catch_);
  ***REMOVED***

  inline v8::Local<v8::Value> ErrnoException(
          int errorno
       ,  const char* syscall = NULL
       ,  const char* message = NULL
       ,  const char* path = NULL) ***REMOVED***
    return node::ErrnoException(v8::Isolate::GetCurrent(), errorno, syscall,
            message, path);
  ***REMOVED***

  NAN_DEPRECATED inline v8::Local<v8::Value> NanErrnoException(
          int errorno
       ,  const char* syscall = NULL
       ,  const char* message = NULL
       ,  const char* path = NULL) ***REMOVED***
    return ErrnoException(errorno, syscall, message, path);
  ***REMOVED***

  template<typename T>
  inline void SetIsolateData(
      v8::Isolate *isolate
    , T *data
  ) ***REMOVED***
      isolate->SetData(0, data);
  ***REMOVED***

  template<typename T>
  inline T *GetIsolateData(
      v8::Isolate *isolate
  ) ***REMOVED***
      return static_cast<T*>(isolate->GetData(0));
  ***REMOVED***

class Utf8String ***REMOVED***
 public:
  inline explicit Utf8String(v8::Local<v8::Value> from) :
      length_(0), str_(str_st_) ***REMOVED***
    HandleScope scope;
    if (!from.IsEmpty()) ***REMOVED***
      v8::Local<v8::String> string = from->ToString();
      if (!string.IsEmpty()) ***REMOVED***
        size_t len = 3 * string->Length() + 1;
        assert(len <= INT_MAX);
        if (len > sizeof (str_st_)) ***REMOVED***
          str_ = static_cast<char*>(malloc(len));
          assert(str_ != 0);
        ***REMOVED***
        const int flags =
            v8::String::NO_NULL_TERMINATION | imp::kReplaceInvalidUtf8;
        length_ = string->WriteUtf8(str_, static_cast<int>(len), 0, flags);
        str_[length_] = '\0';
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  inline int length() const ***REMOVED***
    return length_;
  ***REMOVED***

  inline char* operator*() ***REMOVED*** return str_; ***REMOVED***
  inline const char* operator*() const ***REMOVED*** return str_; ***REMOVED***

  inline ~Utf8String() ***REMOVED***
    if (str_ != str_st_) ***REMOVED***
      free(str_);
    ***REMOVED***
  ***REMOVED***

 private:
  NAN_DISALLOW_ASSIGN_COPY_MOVE(Utf8String)

  int length_;
  char *str_;
  char str_st_[1024];
***REMOVED***;

#else  // Node 0.8 and 0.10
  inline v8::Local<v8::Primitive> Undefined() ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(New(v8::Undefined()));
  ***REMOVED***

  inline v8::Local<v8::Primitive> Null() ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(New(v8::Null()));
  ***REMOVED***

  inline v8::Local<v8::Boolean> True() ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(New(v8::True()));
  ***REMOVED***

  inline v8::Local<v8::Boolean> False() ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(New(v8::False()));
  ***REMOVED***

  inline v8::Local<v8::String> EmptyString() ***REMOVED***
    return v8::String::Empty();
  ***REMOVED***

  inline int AdjustExternalMemory(int bc) ***REMOVED***
    return static_cast<int>(v8::V8::AdjustAmountOfExternalAllocatedMemory(bc));
  ***REMOVED***

  inline void SetTemplate(
      v8::Local<v8::Template> templ
    , const char *name
    , v8::Local<v8::Data> value) ***REMOVED***
    templ->Set(name, value);
  ***REMOVED***

  inline void SetTemplate(
      v8::Local<v8::Template> templ
    , v8::Local<v8::String> name
    , v8::Local<v8::Data> value
    , v8::PropertyAttribute attributes) ***REMOVED***
    templ->Set(name, value, attributes);
  ***REMOVED***

  inline v8::Local<v8::Context> GetCurrentContext() ***REMOVED***
    return v8::Context::GetCurrent();
  ***REMOVED***

  inline void* GetInternalFieldPointer(
      v8::Local<v8::Object> object
    , int index) ***REMOVED***
    return object->GetPointerFromInternalField(index);
  ***REMOVED***

  inline void SetInternalFieldPointer(
      v8::Local<v8::Object> object
    , int index
    , void* value) ***REMOVED***
    object->SetPointerInInternalField(index, value);
  ***REMOVED***

# define NAN_GC_CALLBACK(name)                                                 \
    void name(v8::GCType type, v8::GCCallbackFlags flags)

  inline void AddGCEpilogueCallback(
    v8::GCEpilogueCallback callback
  , v8::GCType gc_type_filter = v8::kGCTypeAll) ***REMOVED***
    v8::V8::AddGCEpilogueCallback(callback, gc_type_filter);
  ***REMOVED***
  inline void RemoveGCEpilogueCallback(
    v8::GCEpilogueCallback callback) ***REMOVED***
    v8::V8::RemoveGCEpilogueCallback(callback);
  ***REMOVED***
  inline void AddGCPrologueCallback(
    v8::GCPrologueCallback callback
  , v8::GCType gc_type_filter = v8::kGCTypeAll) ***REMOVED***
    v8::V8::AddGCPrologueCallback(callback, gc_type_filter);
  ***REMOVED***
  inline void RemoveGCPrologueCallback(
    v8::GCPrologueCallback callback) ***REMOVED***
    v8::V8::RemoveGCPrologueCallback(callback);
  ***REMOVED***
  inline void GetHeapStatistics(
    v8::HeapStatistics *heap_statistics) ***REMOVED***
    v8::V8::GetHeapStatistics(heap_statistics);
  ***REMOVED***

# define X(NAME)                                                               \
    inline v8::Local<v8::Value> NAME(const char *msg) ***REMOVED***                        \
      EscapableHandleScope scope;                                              \
      return scope.Escape(v8::Exception::NAME(New(msg).ToLocalChecked()));     \
    ***REMOVED***                                                                          \
                                                                               \
    inline                                                                     \
    v8::Local<v8::Value> NAME(v8::Local<v8::String> msg) ***REMOVED***                     \
      return v8::Exception::NAME(msg);                                         \
    ***REMOVED***                                                                          \
                                                                               \
    inline void Throw ## NAME(const char *msg) ***REMOVED***                               \
      HandleScope scope;                                                       \
      v8::ThrowException(v8::Exception::NAME(New(msg).ToLocalChecked()));      \
    ***REMOVED***                                                                          \
                                                                               \
    inline                                                                     \
    void Throw ## NAME(v8::Local<v8::String> errmsg) ***REMOVED***                         \
      HandleScope scope;                                                       \
      v8::ThrowException(v8::Exception::NAME(errmsg));                         \
    ***REMOVED***

  X(Error)
  X(RangeError)
  X(ReferenceError)
  X(SyntaxError)
  X(TypeError)

# undef X

  inline void ThrowError(v8::Local<v8::Value> error) ***REMOVED***
    v8::ThrowException(error);
  ***REMOVED***

  inline MaybeLocal<v8::Object> NewBuffer(
      char *data
    , size_t length
    , node::Buffer::free_callback callback
    , void *hint
  ) ***REMOVED***
    EscapableHandleScope scope;
    // arbitrary buffer lengths requires
    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION
    assert(length <= imp::kMaxLength && "too large buffer");
    return scope.Escape(
        New(node::Buffer::New(data, length, callback, hint)->handle_));
  ***REMOVED***

  inline MaybeLocal<v8::Object> CopyBuffer(
      const char *data
    , uint32_t size
  ) ***REMOVED***
    EscapableHandleScope scope;
    // arbitrary buffer lengths requires
    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION
    assert(size <= imp::kMaxLength && "too large buffer");
#if NODE_MODULE_VERSION >= NODE_0_10_MODULE_VERSION
    return scope.Escape(New(node::Buffer::New(data, size)->handle_));
#else
    return scope.Escape(
        New(node::Buffer::New(const_cast<char *>(data), size)->handle_));
#endif
  ***REMOVED***

  inline MaybeLocal<v8::Object> NewBuffer(uint32_t size) ***REMOVED***
    // arbitrary buffer lengths requires
    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION
    EscapableHandleScope scope;
    assert(size <= imp::kMaxLength && "too large buffer");
    return scope.Escape(New(node::Buffer::New(size)->handle_));
  ***REMOVED***

  inline void FreeData(char *data, void *hint) ***REMOVED***
    (void) hint;  // unused
    delete[] data;
  ***REMOVED***

  inline MaybeLocal<v8::Object> NewBuffer(
      char* data
    , uint32_t size
  ) ***REMOVED***
    EscapableHandleScope scope;
    // arbitrary buffer lengths requires
    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION
    assert(size <= imp::kMaxLength && "too large buffer");
    return scope.Escape(
        New(node::Buffer::New(data, size, FreeData, NULL)->handle_));
  ***REMOVED***

namespace imp ***REMOVED***
inline void
widenString(std::vector<uint16_t> *ws, const uint8_t *s, int l) ***REMOVED***
  size_t len = static_cast<size_t>(l);
  if (l < 0) ***REMOVED***
    len = strlen(reinterpret_cast<const char*>(s));
  ***REMOVED***
  assert(len <= INT_MAX && "string too long");
  ws->resize(len);
  std::copy(s, s + len, ws->begin());  // NOLINT(build/include_what_you_use)
***REMOVED***
***REMOVED***  // end of namespace imp

  inline MaybeLocal<v8::String>
  NewOneByteString(const uint8_t * value, int length = -1) ***REMOVED***
    std::vector<uint16_t> wideString;  // NOLINT(build/include_what_you_use)
    imp::widenString(&wideString, value, length);
    return v8::String::New(wideString.data(),
                           static_cast<int>(wideString.size()));
  ***REMOVED***

  inline MaybeLocal<BoundScript> CompileScript(
      v8::Local<v8::String> s
    , const v8::ScriptOrigin& origin
  ) ***REMOVED***
    return v8::Script::Compile(s, const_cast<v8::ScriptOrigin *>(&origin));
  ***REMOVED***

  inline MaybeLocal<BoundScript> CompileScript(
    v8::Local<v8::String> s
  ) ***REMOVED***
    return v8::Script::Compile(s);
  ***REMOVED***

  inline
  MaybeLocal<v8::Value> RunScript(v8::Local<v8::Script> script) ***REMOVED***
    return script->Run();
  ***REMOVED***

  inline v8::Local<v8::Value> MakeCallback(
      v8::Local<v8::Object> target
    , v8::Local<v8::Function> func
    , int argc
    , v8::Local<v8::Value>* argv) ***REMOVED***
    v8::HandleScope scope;
    return scope.Close(New(node::MakeCallback(target, func, argc, argv)));
  ***REMOVED***

  inline v8::Local<v8::Value> MakeCallback(
      v8::Local<v8::Object> target
    , v8::Local<v8::String> symbol
    , int argc
    , v8::Local<v8::Value>* argv) ***REMOVED***
    v8::HandleScope scope;
    return scope.Close(New(node::MakeCallback(target, symbol, argc, argv)));
  ***REMOVED***

  inline v8::Local<v8::Value> MakeCallback(
      v8::Local<v8::Object> target
    , const char* method
    , int argc
    , v8::Local<v8::Value>* argv) ***REMOVED***
    v8::HandleScope scope;
    return scope.Close(New(node::MakeCallback(target, method, argc, argv)));
  ***REMOVED***

  inline void FatalException(const TryCatch& try_catch) ***REMOVED***
    node::FatalException(const_cast<v8::TryCatch &>(try_catch.try_catch_));
  ***REMOVED***

  inline v8::Local<v8::Value> ErrnoException(
          int errorno
       ,  const char* syscall = NULL
       ,  const char* message = NULL
       ,  const char* path = NULL) ***REMOVED***
    return node::ErrnoException(errorno, syscall, message, path);
  ***REMOVED***

  NAN_DEPRECATED inline v8::Local<v8::Value> NanErrnoException(
          int errorno
       ,  const char* syscall = NULL
       ,  const char* message = NULL
       ,  const char* path = NULL) ***REMOVED***
    return ErrnoException(errorno, syscall, message, path);
  ***REMOVED***


  template<typename T>
  inline void SetIsolateData(
      v8::Isolate *isolate
    , T *data
  ) ***REMOVED***
      isolate->SetData(data);
  ***REMOVED***

  template<typename T>
  inline T *GetIsolateData(
      v8::Isolate *isolate
  ) ***REMOVED***
      return static_cast<T*>(isolate->GetData());
  ***REMOVED***

class Utf8String ***REMOVED***
 public:
  inline explicit Utf8String(v8::Local<v8::Value> from) :
      length_(0), str_(str_st_) ***REMOVED***
    v8::HandleScope scope;
    if (!from.IsEmpty()) ***REMOVED***
      v8::Local<v8::String> string = from->ToString();
      if (!string.IsEmpty()) ***REMOVED***
        size_t len = 3 * string->Length() + 1;
        assert(len <= INT_MAX);
        if (len > sizeof (str_st_)) ***REMOVED***
          str_ = static_cast<char*>(malloc(len));
          assert(str_ != 0);
        ***REMOVED***
        const int flags =
            v8::String::NO_NULL_TERMINATION | imp::kReplaceInvalidUtf8;
        length_ = string->WriteUtf8(str_, static_cast<int>(len), 0, flags);
        str_[length_] = '\0';
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  inline int length() const ***REMOVED***
    return length_;
  ***REMOVED***

  inline char* operator*() ***REMOVED*** return str_; ***REMOVED***
  inline const char* operator*() const ***REMOVED*** return str_; ***REMOVED***

  inline ~Utf8String() ***REMOVED***
    if (str_ != str_st_) ***REMOVED***
      free(str_);
    ***REMOVED***
  ***REMOVED***

 private:
  NAN_DISALLOW_ASSIGN_COPY_MOVE(Utf8String)

  int length_;
  char *str_;
  char str_st_[1024];
***REMOVED***;

#endif  // NODE_MODULE_VERSION

typedef void (*FreeCallback)(char *data, void *hint);

typedef const FunctionCallbackInfo<v8::Value>& NAN_METHOD_ARGS_TYPE;
typedef void NAN_METHOD_RETURN_TYPE;

typedef const PropertyCallbackInfo<v8::Value>& NAN_GETTER_ARGS_TYPE;
typedef void NAN_GETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo<void>& NAN_SETTER_ARGS_TYPE;
typedef void NAN_SETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo<v8::Value>&
    NAN_PROPERTY_GETTER_ARGS_TYPE;
typedef void NAN_PROPERTY_GETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo<v8::Value>&
    NAN_PROPERTY_SETTER_ARGS_TYPE;
typedef void NAN_PROPERTY_SETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo<v8::Array>&
    NAN_PROPERTY_ENUMERATOR_ARGS_TYPE;
typedef void NAN_PROPERTY_ENUMERATOR_RETURN_TYPE;

typedef const PropertyCallbackInfo<v8::Boolean>&
    NAN_PROPERTY_DELETER_ARGS_TYPE;
typedef void NAN_PROPERTY_DELETER_RETURN_TYPE;

typedef const PropertyCallbackInfo<v8::Integer>&
    NAN_PROPERTY_QUERY_ARGS_TYPE;
typedef void NAN_PROPERTY_QUERY_RETURN_TYPE;

typedef const PropertyCallbackInfo<v8::Value>& NAN_INDEX_GETTER_ARGS_TYPE;
typedef void NAN_INDEX_GETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo<v8::Value>& NAN_INDEX_SETTER_ARGS_TYPE;
typedef void NAN_INDEX_SETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo<v8::Array>&
    NAN_INDEX_ENUMERATOR_ARGS_TYPE;
typedef void NAN_INDEX_ENUMERATOR_RETURN_TYPE;

typedef const PropertyCallbackInfo<v8::Boolean>&
    NAN_INDEX_DELETER_ARGS_TYPE;
typedef void NAN_INDEX_DELETER_RETURN_TYPE;

typedef const PropertyCallbackInfo<v8::Integer>&
    NAN_INDEX_QUERY_ARGS_TYPE;
typedef void NAN_INDEX_QUERY_RETURN_TYPE;

#define NAN_METHOD(name)                                                       \
    Nan::NAN_METHOD_RETURN_TYPE name(Nan::NAN_METHOD_ARGS_TYPE info)
#define NAN_GETTER(name)                                                       \
    Nan::NAN_GETTER_RETURN_TYPE name(                                          \
        v8::Local<v8::String> property                                         \
      , Nan::NAN_GETTER_ARGS_TYPE info)
#define NAN_SETTER(name)                                                       \
    Nan::NAN_SETTER_RETURN_TYPE name(                                          \
        v8::Local<v8::String> property                                         \
      , v8::Local<v8::Value> value                                             \
      , Nan::NAN_SETTER_ARGS_TYPE info)
#define NAN_PROPERTY_GETTER(name)                                              \
    Nan::NAN_PROPERTY_GETTER_RETURN_TYPE name(                                 \
        v8::Local<v8::String> property                                         \
      , Nan::NAN_PROPERTY_GETTER_ARGS_TYPE info)
#define NAN_PROPERTY_SETTER(name)                                              \
    Nan::NAN_PROPERTY_SETTER_RETURN_TYPE name(                                 \
        v8::Local<v8::String> property                                         \
      , v8::Local<v8::Value> value                                             \
      , Nan::NAN_PROPERTY_SETTER_ARGS_TYPE info)
#define NAN_PROPERTY_ENUMERATOR(name)                                          \
    Nan::NAN_PROPERTY_ENUMERATOR_RETURN_TYPE name(                             \
        Nan::NAN_PROPERTY_ENUMERATOR_ARGS_TYPE info)
#define NAN_PROPERTY_DELETER(name)                                             \
    Nan::NAN_PROPERTY_DELETER_RETURN_TYPE name(                                \
        v8::Local<v8::String> property                                         \
      , Nan::NAN_PROPERTY_DELETER_ARGS_TYPE info)
#define NAN_PROPERTY_QUERY(name)                                               \
    Nan::NAN_PROPERTY_QUERY_RETURN_TYPE name(                                  \
        v8::Local<v8::String> property                                         \
      , Nan::NAN_PROPERTY_QUERY_ARGS_TYPE info)
# define NAN_INDEX_GETTER(name)                                                \
    Nan::NAN_INDEX_GETTER_RETURN_TYPE name(                                    \
        uint32_t index                                                         \
      , Nan::NAN_INDEX_GETTER_ARGS_TYPE info)
#define NAN_INDEX_SETTER(name)                                                 \
    Nan::NAN_INDEX_SETTER_RETURN_TYPE name(                                    \
        uint32_t index                                                         \
      , v8::Local<v8::Value> value                                             \
      , Nan::NAN_INDEX_SETTER_ARGS_TYPE info)
#define NAN_INDEX_ENUMERATOR(name)                                             \
    Nan::NAN_INDEX_ENUMERATOR_RETURN_TYPE                                      \
    name(Nan::NAN_INDEX_ENUMERATOR_ARGS_TYPE info)
#define NAN_INDEX_DELETER(name)                                                \
    Nan::NAN_INDEX_DELETER_RETURN_TYPE name(                                   \
        uint32_t index                                                         \
      , Nan::NAN_INDEX_DELETER_ARGS_TYPE info)
#define NAN_INDEX_QUERY(name)                                                  \
    Nan::NAN_INDEX_QUERY_RETURN_TYPE name(                                     \
        uint32_t index                                                         \
      , Nan::NAN_INDEX_QUERY_ARGS_TYPE info)

class Callback ***REMOVED***
 public:
  Callback() ***REMOVED******REMOVED***

  explicit Callback(const v8::Local<v8::Function> &fn) : handle_(fn) ***REMOVED******REMOVED***

  ~Callback() ***REMOVED***
    handle_.Reset();
  ***REMOVED***

  bool operator==(const Callback &other) const ***REMOVED***
    return handle_ == other.handle_;
  ***REMOVED***

  bool operator!=(const Callback &other) const ***REMOVED***
    return !operator==(other);
  ***REMOVED***

  inline
  v8::Local<v8::Function> operator*() const ***REMOVED*** return GetFunction(); ***REMOVED***

  inline v8::Local<v8::Value> operator()(
      v8::Local<v8::Object> target
    , int argc = 0
    , v8::Local<v8::Value> argv[] = 0) const ***REMOVED***
    return this->Call(target, argc, argv);
  ***REMOVED***

  inline v8::Local<v8::Value> operator()(
      int argc = 0
    , v8::Local<v8::Value> argv[] = 0) const ***REMOVED***
    return this->Call(argc, argv);
  ***REMOVED***

  // TODO(kkoopa): remove
  inline void SetFunction(const v8::Local<v8::Function> &fn) ***REMOVED***
    Reset(fn);
  ***REMOVED***

  inline void Reset(const v8::Local<v8::Function> &fn) ***REMOVED***
    handle_.Reset(fn);
  ***REMOVED***

  inline void Reset() ***REMOVED***
    handle_.Reset();
  ***REMOVED***

  inline v8::Local<v8::Function> GetFunction() const ***REMOVED***
    return New(handle_);
  ***REMOVED***

  inline bool IsEmpty() const ***REMOVED***
    return handle_.IsEmpty();
  ***REMOVED***

  inline v8::Local<v8::Value>
  Call(v8::Local<v8::Object> target
     , int argc
     , v8::Local<v8::Value> argv[]) const ***REMOVED***
#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
    v8::Isolate *isolate = v8::Isolate::GetCurrent();
    return Call_(isolate, target, argc, argv);
#else
    return Call_(target, argc, argv);
#endif
  ***REMOVED***

  inline v8::Local<v8::Value>
  Call(int argc, v8::Local<v8::Value> argv[]) const ***REMOVED***
#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
    v8::Isolate *isolate = v8::Isolate::GetCurrent();
    v8::EscapableHandleScope scope(isolate);
    return scope.Escape(
        Call_(isolate, isolate->GetCurrentContext()->Global(), argc, argv));
#else
    v8::HandleScope scope;
    return scope.Close(Call_(v8::Context::GetCurrent()->Global(), argc, argv));
#endif
  ***REMOVED***

 private:
  NAN_DISALLOW_ASSIGN_COPY_MOVE(Callback)
  Persistent<v8::Function> handle_;

#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
  v8::Local<v8::Value> Call_(v8::Isolate *isolate
                           , v8::Local<v8::Object> target
                           , int argc
                           , v8::Local<v8::Value> argv[]) const ***REMOVED***
    EscapableHandleScope scope;

    v8::Local<v8::Function> callback = New(handle_);
# if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION
    return scope.Escape(New(node::MakeCallback(
        isolate
      , target
      , callback
      , argc
      , argv
    )));
# else
    return scope.Escape(node::MakeCallback(
        isolate
      , target
      , callback
      , argc
      , argv
    ));
# endif
  ***REMOVED***
#else
  v8::Local<v8::Value> Call_(v8::Local<v8::Object> target
                           , int argc
                           , v8::Local<v8::Value> argv[]) const ***REMOVED***
    EscapableHandleScope scope;

    v8::Local<v8::Function> callback = New(handle_);
    return scope.Escape(New(node::MakeCallback(
        target
      , callback
      , argc
      , argv
    )));
  ***REMOVED***
#endif
***REMOVED***;

/* abstract */ class AsyncWorker ***REMOVED***
 public:
  explicit AsyncWorker(Callback *callback_)
      : callback(callback_), errmsg_(NULL) ***REMOVED***
    request.data = this;

    HandleScope scope;
    v8::Local<v8::Object> obj = New<v8::Object>();
    persistentHandle.Reset(obj);
  ***REMOVED***

  virtual ~AsyncWorker() ***REMOVED***
    HandleScope scope;

    if (!persistentHandle.IsEmpty())
      persistentHandle.Reset();
    delete callback;
    delete[] errmsg_;
  ***REMOVED***

  virtual void WorkComplete() ***REMOVED***
    HandleScope scope;

    if (errmsg_ == NULL)
      HandleOKCallback();
    else
      HandleErrorCallback();
    delete callback;
    callback = NULL;
  ***REMOVED***

  inline void SaveToPersistent(
      const char *key, const v8::Local<v8::Value> &value) ***REMOVED***
    HandleScope scope;
    New(persistentHandle)->Set(New(key).ToLocalChecked(), value);
  ***REMOVED***

  inline void SaveToPersistent(
      const v8::Local<v8::String> &key, const v8::Local<v8::Value> &value) ***REMOVED***
    HandleScope scope;
    New(persistentHandle)->Set(key, value);
  ***REMOVED***

  inline void SaveToPersistent(
      uint32_t index, const v8::Local<v8::Value> &value) ***REMOVED***
    HandleScope scope;
    New(persistentHandle)->Set(index, value);
  ***REMOVED***

  inline v8::Local<v8::Value> GetFromPersistent(const char *key) const ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(
        New(persistentHandle)->Get(New(key).ToLocalChecked()));
  ***REMOVED***

  inline v8::Local<v8::Value>
  GetFromPersistent(const v8::Local<v8::String> &key) const ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(New(persistentHandle)->Get(key));
  ***REMOVED***

  inline v8::Local<v8::Value> GetFromPersistent(uint32_t index) const ***REMOVED***
    EscapableHandleScope scope;
    return scope.Escape(New(persistentHandle)->Get(index));
  ***REMOVED***

  virtual void Execute() = 0;

  uv_work_t request;

  virtual void Destroy() ***REMOVED***
      delete this;
  ***REMOVED***

 protected:
  Persistent<v8::Object> persistentHandle;
  Callback *callback;

  virtual void HandleOKCallback() ***REMOVED***
    HandleScope scope;

    callback->Call(0, NULL);
  ***REMOVED***

  virtual void HandleErrorCallback() ***REMOVED***
    HandleScope scope;

    v8::Local<v8::Value> argv[] = ***REMOVED***
      v8::Exception::Error(New<v8::String>(ErrorMessage()).ToLocalChecked())
    ***REMOVED***;
    callback->Call(1, argv);
  ***REMOVED***

  void SetErrorMessage(const char *msg) ***REMOVED***
    delete[] errmsg_;

    size_t size = strlen(msg) + 1;
    errmsg_ = new char[size];
    memcpy(errmsg_, msg, size);
  ***REMOVED***

  const char* ErrorMessage() const ***REMOVED***
    return errmsg_;
  ***REMOVED***

 private:
  NAN_DISALLOW_ASSIGN_COPY_MOVE(AsyncWorker)
  char *errmsg_;
***REMOVED***;

/* abstract */ class AsyncBareProgressWorkerBase : public AsyncWorker ***REMOVED***
 public:
  explicit AsyncBareProgressWorkerBase(Callback *callback_)
      : AsyncWorker(callback_) ***REMOVED***
    uv_async_init(
        uv_default_loop()
      , &async
      , AsyncProgress_
    );
    async.data = this;
  ***REMOVED***

  virtual ~AsyncBareProgressWorkerBase() ***REMOVED***
  ***REMOVED***

  virtual void WorkProgress() = 0;

  virtual void Destroy() ***REMOVED***
      uv_close(reinterpret_cast<uv_handle_t*>(&async), AsyncClose_);
  ***REMOVED***

 private:
  inline static NAUV_WORK_CB(AsyncProgress_) ***REMOVED***
    AsyncBareProgressWorkerBase *worker =
            static_cast<AsyncBareProgressWorkerBase*>(async->data);
    worker->WorkProgress();
  ***REMOVED***

  inline static void AsyncClose_(uv_handle_t* handle) ***REMOVED***
    AsyncBareProgressWorkerBase *worker =
            static_cast<AsyncBareProgressWorkerBase*>(handle->data);
    delete worker;
  ***REMOVED***

 protected:
  uv_async_t async;
***REMOVED***;

template<class T>
/* abstract */
class AsyncBareProgressWorker : public AsyncBareProgressWorkerBase ***REMOVED***
 public:
  explicit AsyncBareProgressWorker(Callback *callback_)
      : AsyncBareProgressWorkerBase(callback_) ***REMOVED***
  ***REMOVED***

  virtual ~AsyncBareProgressWorker() ***REMOVED***
  ***REMOVED***

  class ExecutionProgress ***REMOVED***
    friend class AsyncBareProgressWorker;
   public:
    void Signal() const ***REMOVED***
      uv_async_send(&that_->async);
    ***REMOVED***

    void Send(const T* data, size_t count) const ***REMOVED***
      that_->SendProgress_(data, count);
    ***REMOVED***

   private:
    explicit ExecutionProgress(AsyncBareProgressWorker *that) : that_(that) ***REMOVED******REMOVED***
    NAN_DISALLOW_ASSIGN_COPY_MOVE(ExecutionProgress)
    AsyncBareProgressWorker* const that_;
  ***REMOVED***;

  virtual void Execute(const ExecutionProgress& progress) = 0;
  virtual void HandleProgressCallback(const T *data, size_t size) = 0;

 private:
  void Execute() /*final override*/ ***REMOVED***
    ExecutionProgress progress(this);
    Execute(progress);
  ***REMOVED***

  virtual void SendProgress_(const T *data, size_t count) = 0;
***REMOVED***;

template<class T>
/* abstract */
class AsyncProgressWorkerBase : public AsyncBareProgressWorker<T> ***REMOVED***
 public:
  explicit AsyncProgressWorkerBase(Callback *callback_)
      : AsyncBareProgressWorker<T>(callback_), asyncdata_(NULL), asyncsize_(0) ***REMOVED***
    uv_mutex_init(&async_lock);
  ***REMOVED***

  virtual ~AsyncProgressWorkerBase() ***REMOVED***
    uv_mutex_destroy(&async_lock);

    delete[] asyncdata_;
  ***REMOVED***

  void WorkProgress() ***REMOVED***
    uv_mutex_lock(&async_lock);
    T *data = asyncdata_;
    size_t size = asyncsize_;
    asyncdata_ = NULL;
    uv_mutex_unlock(&async_lock);

    // Don't send progress events after we've already completed.
    if (this->callback) ***REMOVED***
        this->HandleProgressCallback(data, size);
    ***REMOVED***
    delete[] data;
  ***REMOVED***

 private:
  void SendProgress_(const T *data, size_t count) ***REMOVED***
    T *new_data = new T[count];
    ***REMOVED***
      T *it = new_data;
      std::copy(data, data + count, it);
    ***REMOVED***

    uv_mutex_lock(&async_lock);
    T *old_data = asyncdata_;
    asyncdata_ = new_data;
    asyncsize_ = count;
    uv_mutex_unlock(&async_lock);

    delete[] old_data;
    uv_async_send(&this->async);
  ***REMOVED***

  uv_mutex_t async_lock;
  T *asyncdata_;
  size_t asyncsize_;
***REMOVED***;

// This ensures compatibility to the previous un-templated AsyncProgressWorker
// class definition.
typedef AsyncProgressWorkerBase<char> AsyncProgressWorker;

template<class T>
/* abstract */
class AsyncBareProgressQueueWorker : public AsyncBareProgressWorkerBase ***REMOVED***
 public:
  explicit AsyncBareProgressQueueWorker(Callback *callback_)
      : AsyncBareProgressWorkerBase(callback_) ***REMOVED***
  ***REMOVED***

  virtual ~AsyncBareProgressQueueWorker() ***REMOVED***
  ***REMOVED***

  class ExecutionProgress ***REMOVED***
    friend class AsyncBareProgressQueueWorker;
   public:
    void Send(const T* data, size_t count) const ***REMOVED***
      that_->SendProgress_(data, count);
    ***REMOVED***

   private:
    explicit ExecutionProgress(AsyncBareProgressQueueWorker *that)
        : that_(that) ***REMOVED******REMOVED***
    NAN_DISALLOW_ASSIGN_COPY_MOVE(ExecutionProgress)
    AsyncBareProgressQueueWorker* const that_;
  ***REMOVED***;

  virtual void Execute(const ExecutionProgress& progress) = 0;
  virtual void HandleProgressCallback(const T *data, size_t size) = 0;

 private:
  void Execute() /*final override*/ ***REMOVED***
    ExecutionProgress progress(this);
    Execute(progress);
  ***REMOVED***

  virtual void SendProgress_(const T *data, size_t count) = 0;
***REMOVED***;

template<class T>
/* abstract */
class AsyncProgressQueueWorker : public AsyncBareProgressQueueWorker<T> ***REMOVED***
 public:
  explicit AsyncProgressQueueWorker(Callback *callback_)
      : AsyncBareProgressQueueWorker<T>(callback_) ***REMOVED***
    uv_mutex_init(&async_lock);
  ***REMOVED***

  virtual ~AsyncProgressQueueWorker() ***REMOVED***
    uv_mutex_lock(&async_lock);

    while (!asyncdata_.empty()) ***REMOVED***
      std::pair<T*, size_t> &datapair = asyncdata_.front();
      T *data = datapair.first;

      asyncdata_.pop();

      delete[] data;
    ***REMOVED***

    uv_mutex_unlock(&async_lock);
    uv_mutex_destroy(&async_lock);
  ***REMOVED***

  void WorkComplete() ***REMOVED***
    WorkProgress();
    AsyncWorker::WorkComplete();
  ***REMOVED***

  void WorkProgress() ***REMOVED***
    uv_mutex_lock(&async_lock);

    while (!asyncdata_.empty()) ***REMOVED***
      std::pair<T*, size_t> &datapair = asyncdata_.front();

      T *data = datapair.first;
      size_t size = datapair.second;

      asyncdata_.pop();
      uv_mutex_unlock(&async_lock);

      // Don't send progress events after we've already completed.
      if (this->callback) ***REMOVED***
          this->HandleProgressCallback(data, size);
      ***REMOVED***

      delete[] data;

      uv_mutex_lock(&async_lock);
    ***REMOVED***

    uv_mutex_unlock(&async_lock);
  ***REMOVED***

 private:
  void SendProgress_(const T *data, size_t count) ***REMOVED***
    T *new_data = new T[count];
    ***REMOVED***
      T *it = new_data;
      std::copy(data, data + count, it);
    ***REMOVED***

    uv_mutex_lock(&async_lock);
    asyncdata_.push(std::pair<T*, size_t>(new_data, count));
    uv_mutex_unlock(&async_lock);

    uv_async_send(&this->async);
  ***REMOVED***

  uv_mutex_t async_lock;
  std::queue<std::pair<T*, size_t> > asyncdata_;
***REMOVED***;

inline void AsyncExecute (uv_work_t* req) ***REMOVED***
  AsyncWorker *worker = static_cast<AsyncWorker*>(req->data);
  worker->Execute();
***REMOVED***

inline void AsyncExecuteComplete (uv_work_t* req) ***REMOVED***
  AsyncWorker* worker = static_cast<AsyncWorker*>(req->data);
  worker->WorkComplete();
  worker->Destroy();
***REMOVED***

inline void AsyncQueueWorker (AsyncWorker* worker) ***REMOVED***
  uv_queue_work(
      uv_default_loop()
    , &worker->request
    , AsyncExecute
    , reinterpret_cast<uv_after_work_cb>(AsyncExecuteComplete)
  );
***REMOVED***

namespace imp ***REMOVED***

inline
ExternalOneByteStringResource const*
GetExternalResource(v8::Local<v8::String> str) ***REMOVED***
#if NODE_MODULE_VERSION < ATOM_0_21_MODULE_VERSION
    return str->GetExternalAsciiStringResource();
#else
    return str->GetExternalOneByteStringResource();
#endif
***REMOVED***

inline
bool
IsExternal(v8::Local<v8::String> str) ***REMOVED***
#if NODE_MODULE_VERSION < ATOM_0_21_MODULE_VERSION
    return str->IsExternalAscii();
#else
    return str->IsExternalOneByte();
#endif
***REMOVED***

***REMOVED***  // end of namespace imp

enum Encoding ***REMOVED***ASCII, UTF8, BASE64, UCS2, BINARY, HEX, BUFFER***REMOVED***;

#if NODE_MODULE_VERSION < NODE_0_10_MODULE_VERSION
# include "nan_string_bytes.h"  // NOLINT(build/include)
#endif

inline v8::Local<v8::Value> Encode(
    const void *buf, size_t len, enum Encoding encoding = BINARY) ***REMOVED***
#if (NODE_MODULE_VERSION >= ATOM_0_21_MODULE_VERSION)
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  node::encoding node_enc = static_cast<node::encoding>(encoding);

  if (encoding == UCS2) ***REMOVED***
    return node::Encode(
        isolate
      , reinterpret_cast<const uint16_t *>(buf)
      , len / 2);
  ***REMOVED*** else ***REMOVED***
    return node::Encode(
        isolate
      , reinterpret_cast<const char *>(buf)
      , len
      , node_enc);
  ***REMOVED***
#elif (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
  return node::Encode(
      v8::Isolate::GetCurrent()
    , buf, len
    , static_cast<node::encoding>(encoding));
#else
# if NODE_MODULE_VERSION >= NODE_0_10_MODULE_VERSION
  return node::Encode(buf, len, static_cast<node::encoding>(encoding));
# else
  return imp::Encode(reinterpret_cast<const char*>(buf), len, encoding);
# endif
#endif
***REMOVED***

inline ssize_t DecodeBytes(
    v8::Local<v8::Value> val, enum Encoding encoding = BINARY) ***REMOVED***
#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
  return node::DecodeBytes(
      v8::Isolate::GetCurrent()
    , val
    , static_cast<node::encoding>(encoding));
#else
# if (NODE_MODULE_VERSION < NODE_0_10_MODULE_VERSION)
  if (encoding == BUFFER) ***REMOVED***
    return node::DecodeBytes(val, node::BINARY);
  ***REMOVED***
# endif
  return node::DecodeBytes(val, static_cast<node::encoding>(encoding));
#endif
***REMOVED***

inline ssize_t DecodeWrite(
    char *buf
  , size_t len
  , v8::Local<v8::Value> val
  , enum Encoding encoding = BINARY) ***REMOVED***
#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)
  return node::DecodeWrite(
      v8::Isolate::GetCurrent()
    , buf
    , len
    , val
    , static_cast<node::encoding>(encoding));
#else
# if (NODE_MODULE_VERSION < NODE_0_10_MODULE_VERSION)
  if (encoding == BUFFER) ***REMOVED***
    return node::DecodeWrite(buf, len, val, node::BINARY);
  ***REMOVED***
# endif
  return node::DecodeWrite(
      buf
    , len
    , val
    , static_cast<node::encoding>(encoding));
#endif
***REMOVED***

inline void SetPrototypeTemplate(
    v8::Local<v8::FunctionTemplate> templ
  , const char *name
  , v8::Local<v8::Data> value
) ***REMOVED***
  HandleScope scope;
  SetTemplate(templ->PrototypeTemplate(), name, value);
***REMOVED***

inline void SetPrototypeTemplate(
    v8::Local<v8::FunctionTemplate> templ
  , v8::Local<v8::String> name
  , v8::Local<v8::Data> value
  , v8::PropertyAttribute attributes
) ***REMOVED***
  HandleScope scope;
  SetTemplate(templ->PrototypeTemplate(), name, value, attributes);
***REMOVED***

inline void SetInstanceTemplate(
    v8::Local<v8::FunctionTemplate> templ
  , const char *name
  , v8::Local<v8::Data> value
) ***REMOVED***
  HandleScope scope;
  SetTemplate(templ->InstanceTemplate(), name, value);
***REMOVED***

inline void SetInstanceTemplate(
    v8::Local<v8::FunctionTemplate> templ
  , v8::Local<v8::String> name
  , v8::Local<v8::Data> value
  , v8::PropertyAttribute attributes
) ***REMOVED***
  HandleScope scope;
  SetTemplate(templ->InstanceTemplate(), name, value, attributes);
***REMOVED***

namespace imp ***REMOVED***

// Note(@agnat): Helper to distinguish different receiver types. The first
// version deals with receivers derived from v8::Template. The second version
// handles everything else. The final argument only serves as discriminator and
// is unused.
template <typename T>
inline
void
SetMethodAux(T recv,
             v8::Local<v8::String> name,
             v8::Local<v8::FunctionTemplate> tpl,
             v8::Template *) ***REMOVED***
  recv->Set(name, tpl);
***REMOVED***

template <typename T>
inline
void
SetMethodAux(T recv,
             v8::Local<v8::String> name,
             v8::Local<v8::FunctionTemplate> tpl,
             ...) ***REMOVED***
  recv->Set(name, GetFunction(tpl).ToLocalChecked());
***REMOVED***

***REMOVED***  // end of namespace imp

template <typename T, template <typename> class HandleType>
inline void SetMethod(
    HandleType<T> recv
  , const char *name
  , FunctionCallback callback) ***REMOVED***
  HandleScope scope;
  v8::Local<v8::FunctionTemplate> t = New<v8::FunctionTemplate>(callback);
  v8::Local<v8::String> fn_name = New(name).ToLocalChecked();
  t->SetClassName(fn_name);
  // Note(@agnat): Pass an empty T* as discriminator. See note on
  // SetMethodAux(...) above
  imp::SetMethodAux(recv, fn_name, t, static_cast<T*>(0));
***REMOVED***

inline void SetPrototypeMethod(
    v8::Local<v8::FunctionTemplate> recv
  , const char* name, FunctionCallback callback) ***REMOVED***
  HandleScope scope;
  v8::Local<v8::FunctionTemplate> t = New<v8::FunctionTemplate>(
      callback
    , v8::Local<v8::Value>()
    , New<v8::Signature>(recv));
  v8::Local<v8::String> fn_name = New(name).ToLocalChecked();
  recv->PrototypeTemplate()->Set(fn_name, t);
  t->SetClassName(fn_name);
***REMOVED***

//=== Accessors and Such =======================================================

inline void SetAccessor(
    v8::Local<v8::ObjectTemplate> tpl
  , v8::Local<v8::String> name
  , GetterCallback getter
  , SetterCallback setter = 0
  , v8::Local<v8::Value> data = v8::Local<v8::Value>()
  , v8::AccessControl settings = v8::DEFAULT
  , v8::PropertyAttribute attribute = v8::None
  , imp::Sig signature = imp::Sig()) ***REMOVED***
  HandleScope scope;

  imp::NativeGetter getter_ =
      imp::GetterCallbackWrapper;
  imp::NativeSetter setter_ =
      setter ? imp::SetterCallbackWrapper : 0;

  v8::Local<v8::ObjectTemplate> otpl = New<v8::ObjectTemplate>();
  otpl->SetInternalFieldCount(imp::kAccessorFieldCount);
  v8::Local<v8::Object> obj = NewInstance(otpl).ToLocalChecked();

  obj->SetInternalField(
      imp::kGetterIndex
    , New<v8::External>(reinterpret_cast<void *>(getter)));

  if (setter != 0) ***REMOVED***
    obj->SetInternalField(
        imp::kSetterIndex
      , New<v8::External>(reinterpret_cast<void *>(setter)));
  ***REMOVED***

  if (!data.IsEmpty()) ***REMOVED***
    obj->SetInternalField(imp::kDataIndex, data);
  ***REMOVED***

  tpl->SetAccessor(
      name
    , getter_
    , setter_
    , obj
    , settings
    , attribute
    , signature);
***REMOVED***

inline bool SetAccessor(
    v8::Local<v8::Object> obj
  , v8::Local<v8::String> name
  , GetterCallback getter
  , SetterCallback setter = 0
  , v8::Local<v8::Value> data = v8::Local<v8::Value>()
  , v8::AccessControl settings = v8::DEFAULT
  , v8::PropertyAttribute attribute = v8::None) ***REMOVED***
  HandleScope scope;

  imp::NativeGetter getter_ =
      imp::GetterCallbackWrapper;
  imp::NativeSetter setter_ =
      setter ? imp::SetterCallbackWrapper : 0;

  v8::Local<v8::ObjectTemplate> otpl = New<v8::ObjectTemplate>();
  otpl->SetInternalFieldCount(imp::kAccessorFieldCount);
  v8::Local<v8::Object> dataobj = NewInstance(otpl).ToLocalChecked();

  dataobj->SetInternalField(
      imp::kGetterIndex
    , New<v8::External>(reinterpret_cast<void *>(getter)));

  if (!data.IsEmpty()) ***REMOVED***
    dataobj->SetInternalField(imp::kDataIndex, data);
  ***REMOVED***

  if (setter) ***REMOVED***
    dataobj->SetInternalField(
        imp::kSetterIndex
      , New<v8::External>(reinterpret_cast<void *>(setter)));
  ***REMOVED***

#if (NODE_MODULE_VERSION >= NODE_6_0_MODULE_VERSION)
  return obj->SetAccessor(
      GetCurrentContext()
    , name
    , getter_
    , setter_
    , dataobj
    , settings
    , attribute).FromMaybe(false);
#else
  return obj->SetAccessor(
      name
    , getter_
    , setter_
    , dataobj
    , settings
    , attribute);
#endif
***REMOVED***

inline void SetNamedPropertyHandler(
    v8::Local<v8::ObjectTemplate> tpl
  , PropertyGetterCallback getter
  , PropertySetterCallback setter = 0
  , PropertyQueryCallback query = 0
  , PropertyDeleterCallback deleter = 0
  , PropertyEnumeratorCallback enumerator = 0
  , v8::Local<v8::Value> data = v8::Local<v8::Value>()) ***REMOVED***
  HandleScope scope;

  imp::NativePropertyGetter getter_ =
      imp::PropertyGetterCallbackWrapper;
  imp::NativePropertySetter setter_ =
      setter ? imp::PropertySetterCallbackWrapper : 0;
  imp::NativePropertyQuery query_ =
      query ? imp::PropertyQueryCallbackWrapper : 0;
  imp::NativePropertyDeleter *deleter_ =
      deleter ? imp::PropertyDeleterCallbackWrapper : 0;
  imp::NativePropertyEnumerator enumerator_ =
      enumerator ? imp::PropertyEnumeratorCallbackWrapper : 0;

  v8::Local<v8::ObjectTemplate> otpl = New<v8::ObjectTemplate>();
  otpl->SetInternalFieldCount(imp::kPropertyFieldCount);
  v8::Local<v8::Object> obj = NewInstance(otpl).ToLocalChecked();
  obj->SetInternalField(
      imp::kPropertyGetterIndex
    , New<v8::External>(reinterpret_cast<void *>(getter)));

  if (setter) ***REMOVED***
    obj->SetInternalField(
        imp::kPropertySetterIndex
      , New<v8::External>(reinterpret_cast<void *>(setter)));
  ***REMOVED***

  if (query) ***REMOVED***
    obj->SetInternalField(
        imp::kPropertyQueryIndex
      , New<v8::External>(reinterpret_cast<void *>(query)));
  ***REMOVED***

  if (deleter) ***REMOVED***
    obj->SetInternalField(
        imp::kPropertyDeleterIndex
      , New<v8::External>(reinterpret_cast<void *>(deleter)));
  ***REMOVED***

  if (enumerator) ***REMOVED***
    obj->SetInternalField(
        imp::kPropertyEnumeratorIndex
      , New<v8::External>(reinterpret_cast<void *>(enumerator)));
  ***REMOVED***

  if (!data.IsEmpty()) ***REMOVED***
    obj->SetInternalField(imp::kDataIndex, data);
  ***REMOVED***

#if NODE_MODULE_VERSION > NODE_0_12_MODULE_VERSION
  tpl->SetHandler(v8::NamedPropertyHandlerConfiguration(
      getter_, setter_, query_, deleter_, enumerator_, obj));
#else
  tpl->SetNamedPropertyHandler(
      getter_
    , setter_
    , query_
    , deleter_
    , enumerator_
    , obj);
#endif
***REMOVED***

inline void SetIndexedPropertyHandler(
    v8::Local<v8::ObjectTemplate> tpl
  , IndexGetterCallback getter
  , IndexSetterCallback setter = 0
  , IndexQueryCallback query = 0
  , IndexDeleterCallback deleter = 0
  , IndexEnumeratorCallback enumerator = 0
  , v8::Local<v8::Value> data = v8::Local<v8::Value>()) ***REMOVED***
  HandleScope scope;

  imp::NativeIndexGetter getter_ =
      imp::IndexGetterCallbackWrapper;
  imp::NativeIndexSetter setter_ =
      setter ? imp::IndexSetterCallbackWrapper : 0;
  imp::NativeIndexQuery query_ =
      query ? imp::IndexQueryCallbackWrapper : 0;
  imp::NativeIndexDeleter deleter_ =
      deleter ? imp::IndexDeleterCallbackWrapper : 0;
  imp::NativeIndexEnumerator enumerator_ =
      enumerator ? imp::IndexEnumeratorCallbackWrapper : 0;

  v8::Local<v8::ObjectTemplate> otpl = New<v8::ObjectTemplate>();
  otpl->SetInternalFieldCount(imp::kIndexPropertyFieldCount);
  v8::Local<v8::Object> obj = NewInstance(otpl).ToLocalChecked();
  obj->SetInternalField(
      imp::kIndexPropertyGetterIndex
    , New<v8::External>(reinterpret_cast<void *>(getter)));

  if (setter) ***REMOVED***
    obj->SetInternalField(
        imp::kIndexPropertySetterIndex
      , New<v8::External>(reinterpret_cast<void *>(setter)));
  ***REMOVED***

  if (query) ***REMOVED***
    obj->SetInternalField(
        imp::kIndexPropertyQueryIndex
      , New<v8::External>(reinterpret_cast<void *>(query)));
  ***REMOVED***

  if (deleter) ***REMOVED***
    obj->SetInternalField(
        imp::kIndexPropertyDeleterIndex
      , New<v8::External>(reinterpret_cast<void *>(deleter)));
  ***REMOVED***

  if (enumerator) ***REMOVED***
    obj->SetInternalField(
        imp::kIndexPropertyEnumeratorIndex
      , New<v8::External>(reinterpret_cast<void *>(enumerator)));
  ***REMOVED***

  if (!data.IsEmpty()) ***REMOVED***
    obj->SetInternalField(imp::kDataIndex, data);
  ***REMOVED***

#if NODE_MODULE_VERSION > NODE_0_12_MODULE_VERSION
  tpl->SetHandler(v8::IndexedPropertyHandlerConfiguration(
      getter_, setter_, query_, deleter_, enumerator_, obj));
#else
  tpl->SetIndexedPropertyHandler(
      getter_
    , setter_
    , query_
    , deleter_
    , enumerator_
    , obj);
#endif
***REMOVED***

inline void SetCallHandler(
    v8::Local<v8::FunctionTemplate> tpl
  , FunctionCallback callback
  , v8::Local<v8::Value> data = v8::Local<v8::Value>()) ***REMOVED***
  HandleScope scope;

  v8::Local<v8::ObjectTemplate> otpl = New<v8::ObjectTemplate>();
  otpl->SetInternalFieldCount(imp::kFunctionFieldCount);
  v8::Local<v8::Object> obj = NewInstance(otpl).ToLocalChecked();

  obj->SetInternalField(
      imp::kFunctionIndex
    , New<v8::External>(reinterpret_cast<void *>(callback)));

  if (!data.IsEmpty()) ***REMOVED***
    obj->SetInternalField(imp::kDataIndex, data);
  ***REMOVED***

  tpl->SetCallHandler(imp::FunctionCallbackWrapper, obj);
***REMOVED***


inline void SetCallAsFunctionHandler(
    v8::Local<v8::ObjectTemplate> tpl,
    FunctionCallback callback,
    v8::Local<v8::Value> data = v8::Local<v8::Value>()) ***REMOVED***
  HandleScope scope;

  v8::Local<v8::ObjectTemplate> otpl = New<v8::ObjectTemplate>();
  otpl->SetInternalFieldCount(imp::kFunctionFieldCount);
  v8::Local<v8::Object> obj = NewInstance(otpl).ToLocalChecked();

  obj->SetInternalField(
      imp::kFunctionIndex
    , New<v8::External>(reinterpret_cast<void *>(callback)));

  if (!data.IsEmpty()) ***REMOVED***
    obj->SetInternalField(imp::kDataIndex, data);
  ***REMOVED***

  tpl->SetCallAsFunctionHandler(imp::FunctionCallbackWrapper, obj);
***REMOVED***

//=== Weak Persistent Handling =================================================

#include "nan_weak.h"  // NOLINT(build/include)

//=== ObjectWrap ===============================================================

#include "nan_object_wrap.h"  // NOLINT(build/include)

//=== HiddenValue/Private ======================================================

#include "nan_private.h"  // NOLINT(build/include)

//=== Export ==================================================================

inline
void
Export(ADDON_REGISTER_FUNCTION_ARGS_TYPE target, const char *name,
    FunctionCallback f) ***REMOVED***
  HandleScope scope;

  Set(target, New<v8::String>(name).ToLocalChecked(),
      GetFunction(New<v8::FunctionTemplate>(f)).ToLocalChecked());
***REMOVED***

//=== Tap Reverse Binding =====================================================

struct Tap ***REMOVED***
  explicit Tap(v8::Local<v8::Value> t) : t_() ***REMOVED***
    HandleScope scope;

    t_.Reset(To<v8::Object>(t).ToLocalChecked());
  ***REMOVED***

  ~Tap() ***REMOVED*** t_.Reset(); ***REMOVED***  // not sure if neccessary

  inline void plan(int i) ***REMOVED***
    HandleScope scope;
    v8::Local<v8::Value> arg = New(i);
    MakeCallback(New(t_), "plan", 1, &arg);
  ***REMOVED***

  inline void ok(bool isOk, const char *msg = NULL) ***REMOVED***
    HandleScope scope;
    v8::Local<v8::Value> args[2];
    args[0] = New(isOk);
    if (msg) args[1] = New(msg).ToLocalChecked();
    MakeCallback(New(t_), "ok", msg ? 2 : 1, args);
  ***REMOVED***

  inline void pass(const char * msg = NULL) ***REMOVED***
    HandleScope scope;
    v8::Local<v8::Value> hmsg;
    if (msg) hmsg = New(msg).ToLocalChecked();
    MakeCallback(New(t_), "pass", msg ? 1 : 0, &hmsg);
  ***REMOVED***

 private:
  Persistent<v8::Object> t_;
***REMOVED***;

#define NAN_STRINGIZE2(x) #x
#define NAN_STRINGIZE(x) NAN_STRINGIZE2(x)
#define NAN_TEST_EXPRESSION(expression) \
  ( expression ), __FILE__ ":" NAN_STRINGIZE(__LINE__) ": " #expression

#define NAN_EXPORT(target, function) Export(target, #function, function)

#undef TYPE_CHECK

//=== Generic Maybefication ===================================================

namespace imp ***REMOVED***

template <typename T> struct Maybefier;

template <typename T> struct Maybefier<v8::Local<T> > ***REMOVED***
  inline static MaybeLocal<T> convert(v8::Local<T> v) ***REMOVED***
    return v;
  ***REMOVED***
***REMOVED***;

template <typename T> struct Maybefier<MaybeLocal<T> > ***REMOVED***
  inline static MaybeLocal<T> convert(MaybeLocal<T> v) ***REMOVED***
    return v;
  ***REMOVED***
***REMOVED***;

***REMOVED***  // end of namespace imp

template <typename T, template <typename> class MaybeMaybe>
inline MaybeLocal<T>
MakeMaybe(MaybeMaybe<T> v) ***REMOVED***
  return imp::Maybefier<MaybeMaybe<T> >::convert(v);
***REMOVED***

//=== TypedArrayContents =======================================================

#include "nan_typedarray_contents.h"  // NOLINT(build/include)

//=== JSON =====================================================================

#include "nan_json.h"  // NOLINT(build/include)

***REMOVED***  // end of namespace Nan

#endif  // NAN_H_
