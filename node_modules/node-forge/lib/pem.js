/**
 * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.
 *
 * See: RFC 1421.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 *
 * A Forge PEM object has the following fields:
 *
 * type: identifies the type of message (eg: "RSA PRIVATE KEY").
 *
 * procType: identifies the type of processing performed on the message,
 *   it has two subfields: version and type, eg: 4,ENCRYPTED.
 *
 * contentDomain: identifies the type of content in the message, typically
 *   only uses the value: "RFC822".
 *
 * dekInfo: identifies the message encryption algorithm and mode and includes
 *   any parameters for the algorithm, it has two subfields: algorithm and
 *   parameters, eg: DES-CBC,F8143EDE5960C597.
 *
 * headers: contains all other PEM encapsulated headers -- where order is
 *   significant (for pairing data like recipient ID + key info).
 *
 * body: the binary-encoded body.
 */
var forge = require('./forge');
require('./util');

// shortcut for pem API
var pem = module.exports = forge.pem = forge.pem || ***REMOVED******REMOVED***;

/**
 * Encodes (serializes) the given PEM object.
 *
 * @param msg the PEM message object to encode.
 * @param options the options to use:
 *          maxline the maximum characters per line for the body, (default: 64).
 *
 * @return the PEM-formatted string.
 */
pem.encode = function(msg, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  var rval = '-----BEGIN ' + msg.type + '-----\r\n';

  // encode special headers
  var header;
  if(msg.procType) ***REMOVED***
    header = ***REMOVED***
      name: 'Proc-Type',
      values: [String(msg.procType.version), msg.procType.type]
    ***REMOVED***;
    rval += foldHeader(header);
  ***REMOVED***
  if(msg.contentDomain) ***REMOVED***
    header = ***REMOVED***name: 'Content-Domain', values: [msg.contentDomain]***REMOVED***;
    rval += foldHeader(header);
  ***REMOVED***
  if(msg.dekInfo) ***REMOVED***
    header = ***REMOVED***name: 'DEK-Info', values: [msg.dekInfo.algorithm]***REMOVED***;
    if(msg.dekInfo.parameters) ***REMOVED***
      header.values.push(msg.dekInfo.parameters);
    ***REMOVED***
    rval += foldHeader(header);
  ***REMOVED***

  if(msg.headers) ***REMOVED***
    // encode all other headers
    for(var i = 0; i < msg.headers.length; ++i) ***REMOVED***
      rval += foldHeader(msg.headers[i]);
    ***REMOVED***
  ***REMOVED***

  // terminate header
  if(msg.procType) ***REMOVED***
    rval += '\r\n';
  ***REMOVED***

  // add body
  rval += forge.util.encode64(msg.body, options.maxline || 64) + '\r\n';

  rval += '-----END ' + msg.type + '-----\r\n';
  return rval;
***REMOVED***;

/**
 * Decodes (deserializes) all PEM messages found in the given string.
 *
 * @param str the PEM-formatted string to decode.
 *
 * @return the PEM message objects in an array.
 */
pem.decode = function(str) ***REMOVED***
  var rval = [];

  // split string into PEM messages (be lenient w/EOF on BEGIN line)
  var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
  var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
  var rCRLF = /\r?\n/;
  var match;
  while(true) ***REMOVED***
    match = rMessage.exec(str);
    if(!match) ***REMOVED***
      break;
    ***REMOVED***

    var msg = ***REMOVED***
      type: match[1],
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: forge.util.decode64(match[3])
    ***REMOVED***;
    rval.push(msg);

    // no headers
    if(!match[2]) ***REMOVED***
      continue;
    ***REMOVED***

    // parse headers
    var lines = match[2].split(rCRLF);
    var li = 0;
    while(match && li < lines.length) ***REMOVED***
      // get line, trim any rhs whitespace
      var line = lines[li].replace(/\s+$/, '');

      // RFC2822 unfold any following folded lines
      for(var nl = li + 1; nl < lines.length; ++nl) ***REMOVED***
        var next = lines[nl];
        if(!/\s/.test(next[0])) ***REMOVED***
          break;
        ***REMOVED***
        line += next;
        li = nl;
      ***REMOVED***

      // parse header
      match = line.match(rHeader);
      if(match) ***REMOVED***
        var header = ***REMOVED***name: match[1], values: []***REMOVED***;
        var values = match[2].split(',');
        for(var vi = 0; vi < values.length; ++vi) ***REMOVED***
          header.values.push(ltrim(values[vi]));
        ***REMOVED***

        // Proc-Type must be the first header
        if(!msg.procType) ***REMOVED***
          if(header.name !== 'Proc-Type') ***REMOVED***
            throw new Error('Invalid PEM formatted message. The first ' +
              'encapsulated header must be "Proc-Type".');
          ***REMOVED*** else if(header.values.length !== 2) ***REMOVED***
            throw new Error('Invalid PEM formatted message. The "Proc-Type" ' +
              'header must have two subfields.');
          ***REMOVED***
          msg.procType = ***REMOVED***version: values[0], type: values[1]***REMOVED***;
        ***REMOVED*** else if(!msg.contentDomain && header.name === 'Content-Domain') ***REMOVED***
          // special-case Content-Domain
          msg.contentDomain = values[0] || '';
        ***REMOVED*** else if(!msg.dekInfo && header.name === 'DEK-Info') ***REMOVED***
          // special-case DEK-Info
          if(header.values.length === 0) ***REMOVED***
            throw new Error('Invalid PEM formatted message. The "DEK-Info" ' +
              'header must have at least one subfield.');
          ***REMOVED***
          msg.dekInfo = ***REMOVED***algorithm: values[0], parameters: values[1] || null***REMOVED***;
        ***REMOVED*** else ***REMOVED***
          msg.headers.push(header);
        ***REMOVED***
      ***REMOVED***

      ++li;
    ***REMOVED***

    if(msg.procType === 'ENCRYPTED' && !msg.dekInfo) ***REMOVED***
      throw new Error('Invalid PEM formatted message. The "DEK-Info" ' +
        'header must be present if "Proc-Type" is "ENCRYPTED".');
    ***REMOVED***
  ***REMOVED***

  if(rval.length === 0) ***REMOVED***
    throw new Error('Invalid PEM formatted message.');
  ***REMOVED***

  return rval;
***REMOVED***;

function foldHeader(header) ***REMOVED***
  var rval = header.name + ': ';

  // ensure values with CRLF are folded
  var values = [];
  var insertSpace = function(match, $1) ***REMOVED***
    return ' ' + $1;
  ***REMOVED***;
  for(var i = 0; i < header.values.length; ++i) ***REMOVED***
    values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
  ***REMOVED***
  rval += values.join(',') + '\r\n';

  // do folding
  var length = 0;
  var candidate = -1;
  for(var i = 0; i < rval.length; ++i, ++length) ***REMOVED***
    if(length > 65 && candidate !== -1) ***REMOVED***
      var insert = rval[candidate];
      if(insert === ',') ***REMOVED***
        ++candidate;
        rval = rval.substr(0, candidate) + '\r\n ' + rval.substr(candidate);
      ***REMOVED*** else ***REMOVED***
        rval = rval.substr(0, candidate) +
          '\r\n' + insert + rval.substr(candidate + 1);
      ***REMOVED***
      length = (i - candidate - 1);
      candidate = -1;
      ++i;
    ***REMOVED*** else if(rval[i] === ' ' || rval[i] === '\t' || rval[i] === ',') ***REMOVED***
      candidate = i;
    ***REMOVED***
  ***REMOVED***

  return rval;
***REMOVED***

function ltrim(str) ***REMOVED***
  return str.replace(/^\s+/, '');
***REMOVED***
