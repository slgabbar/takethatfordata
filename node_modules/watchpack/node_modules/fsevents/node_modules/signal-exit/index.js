// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
var assert = require('assert')
var signals = require('./signals.js')

var EE = require('events')
/* istanbul ignore if */
if (typeof EE !== 'function') ***REMOVED***
  EE = EE.EventEmitter
***REMOVED***

var emitter
if (process.__signal_exit_emitter__) ***REMOVED***
  emitter = process.__signal_exit_emitter__
***REMOVED*** else ***REMOVED***
  emitter = process.__signal_exit_emitter__ = new EE()
  emitter.count = 0
  emitter.emitted = ***REMOVED******REMOVED***
***REMOVED***

// Because this emitter is a global, we have to check to see if a
// previous version of this library failed to enable infinite listeners.
// I know what you're about to say.  But literally everything about
// signal-exit is a compromise with evil.  Get used to it.
if (!emitter.infinite) ***REMOVED***
  emitter.setMaxListeners(Infinity)
  emitter.infinite = true
***REMOVED***

module.exports = function (cb, opts) ***REMOVED***
  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')

  if (loaded === false) ***REMOVED***
    load()
  ***REMOVED***

  var ev = 'exit'
  if (opts && opts.alwaysLast) ***REMOVED***
    ev = 'afterexit'
  ***REMOVED***

  var remove = function () ***REMOVED***
    emitter.removeListener(ev, cb)
    if (emitter.listeners('exit').length === 0 &&
        emitter.listeners('afterexit').length === 0) ***REMOVED***
      unload()
    ***REMOVED***
  ***REMOVED***
  emitter.on(ev, cb)

  return remove
***REMOVED***

module.exports.unload = unload
function unload () ***REMOVED***
  if (!loaded) ***REMOVED***
    return
  ***REMOVED***
  loaded = false

  signals.forEach(function (sig) ***REMOVED***
    try ***REMOVED***
      process.removeListener(sig, sigListeners[sig])
    ***REMOVED*** catch (er) ***REMOVED******REMOVED***
  ***REMOVED***)
  process.emit = originalProcessEmit
  process.reallyExit = originalProcessReallyExit
  emitter.count -= 1
***REMOVED***

function emit (event, code, signal) ***REMOVED***
  if (emitter.emitted[event]) ***REMOVED***
    return
  ***REMOVED***
  emitter.emitted[event] = true
  emitter.emit(event, code, signal)
***REMOVED***

// ***REMOVED*** <signal>: <listener fn>, ... ***REMOVED***
var sigListeners = ***REMOVED******REMOVED***
signals.forEach(function (sig) ***REMOVED***
  sigListeners[sig] = function listener () ***REMOVED***
    // If there are no other listeners, an exit is coming!
    // Simplest way: remove us and then re-send the signal.
    // We know that this will kill the process, so we can
    // safely emit now.
    var listeners = process.listeners(sig)
    if (listeners.length === emitter.count) ***REMOVED***
      unload()
      emit('exit', null, sig)
      /* istanbul ignore next */
      emit('afterexit', null, sig)
      /* istanbul ignore next */
      process.kill(process.pid, sig)
    ***REMOVED***
  ***REMOVED***
***REMOVED***)

module.exports.signals = function () ***REMOVED***
  return signals
***REMOVED***

module.exports.load = load

var loaded = false

function load () ***REMOVED***
  if (loaded) ***REMOVED***
    return
  ***REMOVED***
  loaded = true

  // This is the number of onSignalExit's that are in play.
  // It's important so that we can count the correct number of
  // listeners on signals, and don't wait for the other one to
  // handle it instead of us.
  emitter.count += 1

  signals = signals.filter(function (sig) ***REMOVED***
    try ***REMOVED***
      process.on(sig, sigListeners[sig])
      return true
    ***REMOVED*** catch (er) ***REMOVED***
      return false
    ***REMOVED***
  ***REMOVED***)

  process.emit = processEmit
  process.reallyExit = processReallyExit
***REMOVED***

var originalProcessReallyExit = process.reallyExit
function processReallyExit (code) ***REMOVED***
  process.exitCode = code || 0
  emit('exit', process.exitCode, null)
  /* istanbul ignore next */
  emit('afterexit', process.exitCode, null)
  /* istanbul ignore next */
  originalProcessReallyExit.call(process, process.exitCode)
***REMOVED***

var originalProcessEmit = process.emit
function processEmit (ev, arg) ***REMOVED***
  if (ev === 'exit') ***REMOVED***
    if (arg !== undefined) ***REMOVED***
      process.exitCode = arg
    ***REMOVED***
    var ret = originalProcessEmit.apply(this, arguments)
    emit('exit', process.exitCode, null)
    /* istanbul ignore next */
    emit('afterexit', process.exitCode, null)
    return ret
  ***REMOVED*** else ***REMOVED***
    return originalProcessEmit.apply(this, arguments)
  ***REMOVED***
***REMOVED***
