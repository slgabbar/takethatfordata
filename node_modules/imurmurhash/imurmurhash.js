/**
 * @preserve
 * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
 *
 * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
 * @see http://github.com/homebrewing/brauhaus-diff
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 */
(function()***REMOVED***
    var cache;

    // Call this function without `new` to use the cached object (good for
    // single-threaded environments), or with `new` to create a new object.
    //
    // @param ***REMOVED***string***REMOVED*** key A UTF-16 or ASCII string
    // @param ***REMOVED***number***REMOVED*** seed An optional positive integer
    // @return ***REMOVED***object***REMOVED*** A MurmurHash3 object for incremental hashing
    function MurmurHash3(key, seed) ***REMOVED***
        var m = this instanceof MurmurHash3 ? this : cache;
        m.reset(seed)
        if (typeof key === 'string' && key.length > 0) ***REMOVED***
            m.hash(key);
        ***REMOVED***

        if (m !== this) ***REMOVED***
            return m;
        ***REMOVED***
    ***REMOVED***;

    // Incrementally add a string to this hash
    //
    // @param ***REMOVED***string***REMOVED*** key A UTF-16 or ASCII string
    // @return ***REMOVED***object***REMOVED*** this
    MurmurHash3.prototype.hash = function(key) ***REMOVED***
        var h1, k1, i, top, len;

        len = key.length;
        this.len += len;

        k1 = this.k1;
        i = 0;
        switch (this.rem) ***REMOVED***
            case 0: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) : 0;
            case 1: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 8 : 0;
            case 2: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 16 : 0;
            case 3:
                k1 ^= len > i ? (key.charCodeAt(i) & 0xff) << 24 : 0;
                k1 ^= len > i ? (key.charCodeAt(i++) & 0xff00) >> 8 : 0;
        ***REMOVED***

        this.rem = (len + this.rem) & 3; // & 3 is same as % 4
        len -= this.rem;
        if (len > 0) ***REMOVED***
            h1 = this.h1;
            while (1) ***REMOVED***
                k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;
                k1 = (k1 << 15) | (k1 >>> 17);
                k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;

                h1 ^= k1;
                h1 = (h1 << 13) | (h1 >>> 19);
                h1 = (h1 * 5 + 0xe6546b64) & 0xffffffff;

                if (i >= len) ***REMOVED***
                    break;
                ***REMOVED***

                k1 = ((key.charCodeAt(i++) & 0xffff)) ^
                     ((key.charCodeAt(i++) & 0xffff) << 8) ^
                     ((key.charCodeAt(i++) & 0xffff) << 16);
                top = key.charCodeAt(i++);
                k1 ^= ((top & 0xff) << 24) ^
                      ((top & 0xff00) >> 8);
            ***REMOVED***

            k1 = 0;
            switch (this.rem) ***REMOVED***
                case 3: k1 ^= (key.charCodeAt(i + 2) & 0xffff) << 16;
                case 2: k1 ^= (key.charCodeAt(i + 1) & 0xffff) << 8;
                case 1: k1 ^= (key.charCodeAt(i) & 0xffff);
            ***REMOVED***

            this.h1 = h1;
        ***REMOVED***

        this.k1 = k1;
        return this;
    ***REMOVED***;

    // Get the result of this hash
    //
    // @return ***REMOVED***number***REMOVED*** The 32-bit hash
    MurmurHash3.prototype.result = function() ***REMOVED***
        var k1, h1;
        
        k1 = this.k1;
        h1 = this.h1;

        if (k1 > 0) ***REMOVED***
            k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;
            k1 = (k1 << 15) | (k1 >>> 17);
            k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;
            h1 ^= k1;
        ***REMOVED***

        h1 ^= this.len;

        h1 ^= h1 >>> 16;
        h1 = (h1 * 0xca6b + (h1 & 0xffff) * 0x85eb0000) & 0xffffffff;
        h1 ^= h1 >>> 13;
        h1 = (h1 * 0xae35 + (h1 & 0xffff) * 0xc2b20000) & 0xffffffff;
        h1 ^= h1 >>> 16;

        return h1 >>> 0;
    ***REMOVED***;

    // Reset the hash object for reuse
    //
    // @param ***REMOVED***number***REMOVED*** seed An optional positive integer
    MurmurHash3.prototype.reset = function(seed) ***REMOVED***
        this.h1 = typeof seed === 'number' ? seed : 0;
        this.rem = this.k1 = this.len = 0;
        return this;
    ***REMOVED***;

    // A cached object to use. This can be safely used if you're in a single-
    // threaded environment, otherwise you need to create new hashes to use.
    cache = new MurmurHash3();

    if (typeof(module) != 'undefined') ***REMOVED***
        module.exports = MurmurHash3;
    ***REMOVED*** else ***REMOVED***
        this.MurmurHash3 = MurmurHash3;
    ***REMOVED***
***REMOVED***());
