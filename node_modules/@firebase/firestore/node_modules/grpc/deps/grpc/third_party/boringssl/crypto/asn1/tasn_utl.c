/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.] */

#include <openssl/asn1.h>

#include <assert.h>
#include <string.h>

#include <openssl/asn1t.h>
#include <openssl/mem.h>
#include <openssl/obj.h>
#include <openssl/err.h>
#include <openssl/thread.h>

#include "../internal.h"


/* Utility functions for manipulating fields and offsets */

/* Add 'offset' to 'addr' */
#define offset2ptr(addr, offset) (void *)(((char *)(addr)) + (offset))

/* Given an ASN1_ITEM CHOICE type return the selector value */
int asn1_get_choice_selector(ASN1_VALUE **pval, const ASN1_ITEM *it) ***REMOVED***
  int *sel = offset2ptr(*pval, it->utype);
  return *sel;
***REMOVED***

/* Given an ASN1_ITEM CHOICE type set the selector value, return old value. */
int asn1_set_choice_selector(ASN1_VALUE **pval, int value,
                             const ASN1_ITEM *it) ***REMOVED***
  int *sel, ret;
  sel = offset2ptr(*pval, it->utype);
  ret = *sel;
  *sel = value;
  return ret;
***REMOVED***

static CRYPTO_refcount_t *asn1_get_references(ASN1_VALUE **pval,
                                              const ASN1_ITEM *it) ***REMOVED***
  if (it->itype != ASN1_ITYPE_SEQUENCE &&
      it->itype != ASN1_ITYPE_NDEF_SEQUENCE) ***REMOVED***
    return NULL;
  ***REMOVED***
  const ASN1_AUX *aux = it->funcs;
  if (!aux || !(aux->flags & ASN1_AFLG_REFCOUNT)) ***REMOVED***
    return NULL;
  ***REMOVED***
  return offset2ptr(*pval, aux->ref_offset);
***REMOVED***

void asn1_refcount_set_one(ASN1_VALUE **pval, const ASN1_ITEM *it) ***REMOVED***
  CRYPTO_refcount_t *references = asn1_get_references(pval, it);
  if (references != NULL) ***REMOVED***
    *references = 1;
  ***REMOVED***
***REMOVED***

int asn1_refcount_dec_and_test_zero(ASN1_VALUE **pval, const ASN1_ITEM *it) ***REMOVED***
  CRYPTO_refcount_t *references = asn1_get_references(pval, it);
  if (references != NULL) ***REMOVED***
    return CRYPTO_refcount_dec_and_test_zero(references);
  ***REMOVED***
  return 1;
***REMOVED***

static ASN1_ENCODING *asn1_get_enc_ptr(ASN1_VALUE **pval, const ASN1_ITEM *it) ***REMOVED***
  const ASN1_AUX *aux;
  if (!pval || !*pval) ***REMOVED***
    return NULL;
  ***REMOVED***
  aux = it->funcs;
  if (!aux || !(aux->flags & ASN1_AFLG_ENCODING)) ***REMOVED***
    return NULL;
  ***REMOVED***
  return offset2ptr(*pval, aux->enc_offset);
***REMOVED***

void asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it) ***REMOVED***
  ASN1_ENCODING *enc;
  enc = asn1_get_enc_ptr(pval, it);
  if (enc) ***REMOVED***
    enc->enc = NULL;
    enc->len = 0;
    enc->alias_only = 0;
    enc->alias_only_on_next_parse = 0;
    enc->modified = 1;
  ***REMOVED***
***REMOVED***

void asn1_enc_free(ASN1_VALUE **pval, const ASN1_ITEM *it) ***REMOVED***
  ASN1_ENCODING *enc;
  enc = asn1_get_enc_ptr(pval, it);
  if (enc) ***REMOVED***
    if (enc->enc && !enc->alias_only) ***REMOVED***
      OPENSSL_free(enc->enc);
    ***REMOVED***
    enc->enc = NULL;
    enc->len = 0;
    enc->alias_only = 0;
    enc->alias_only_on_next_parse = 0;
    enc->modified = 1;
  ***REMOVED***
***REMOVED***

int asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen,
                  const ASN1_ITEM *it) ***REMOVED***
  ASN1_ENCODING *enc;
  enc = asn1_get_enc_ptr(pval, it);
  if (!enc) ***REMOVED***
    return 1;
  ***REMOVED***

  if (!enc->alias_only) ***REMOVED***
    OPENSSL_free(enc->enc);
  ***REMOVED***

  enc->alias_only = enc->alias_only_on_next_parse;
  enc->alias_only_on_next_parse = 0;

  if (enc->alias_only) ***REMOVED***
    enc->enc = (uint8_t *) in;
  ***REMOVED*** else ***REMOVED***
    enc->enc = OPENSSL_malloc(inlen);
    if (!enc->enc) ***REMOVED***
      return 0;
    ***REMOVED***
    OPENSSL_memcpy(enc->enc, in, inlen);
  ***REMOVED***

  enc->len = inlen;
  enc->modified = 0;

  return 1;
***REMOVED***

int asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval,
                     const ASN1_ITEM *it) ***REMOVED***
  ASN1_ENCODING *enc;
  enc = asn1_get_enc_ptr(pval, it);
  if (!enc || enc->modified) ***REMOVED***
    return 0;
  ***REMOVED***
  if (out) ***REMOVED***
    OPENSSL_memcpy(*out, enc->enc, enc->len);
    *out += enc->len;
  ***REMOVED***
  if (len) ***REMOVED***
    *len = enc->len;
  ***REMOVED***
  return 1;
***REMOVED***

/* Given an ASN1_TEMPLATE get a pointer to a field */
ASN1_VALUE **asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) ***REMOVED***
  ASN1_VALUE **pvaltmp;
  if (tt->flags & ASN1_TFLG_COMBINE) ***REMOVED***
    return pval;
  ***REMOVED***
  pvaltmp = offset2ptr(*pval, tt->offset);
  /* NOTE for BOOLEAN types the field is just a plain int so we can't return
   * int **, so settle for (int *). */
  return pvaltmp;
***REMOVED***

/* Handle ANY DEFINED BY template, find the selector, look up the relevant
 * ASN1_TEMPLATE in the table and return it. */
const ASN1_TEMPLATE *asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt,
                                 int nullerr) ***REMOVED***
  const ASN1_ADB *adb;
  const ASN1_ADB_TABLE *atbl;
  long selector;
  ASN1_VALUE **sfld;
  int i;
  if (!(tt->flags & ASN1_TFLG_ADB_MASK)) ***REMOVED***
    return tt;
  ***REMOVED***

  /* Else ANY DEFINED BY ... get the table */
  adb = ASN1_ADB_ptr(tt->item);

  /* Get the selector field */
  sfld = offset2ptr(*pval, adb->offset);

  /* Check if NULL */
  if (*sfld == NULL) ***REMOVED***
    if (!adb->null_tt) ***REMOVED***
      goto err;
    ***REMOVED***
    return adb->null_tt;
  ***REMOVED***

  /* Convert type to a long:
   * NB: don't check for NID_undef here because it
   * might be a legitimate value in the table */
  if (tt->flags & ASN1_TFLG_ADB_OID) ***REMOVED***
    selector = OBJ_obj2nid((ASN1_OBJECT *)*sfld);
  ***REMOVED*** else ***REMOVED***
    selector = ASN1_INTEGER_get((ASN1_INTEGER *)*sfld);
  ***REMOVED***

  /* Try to find matching entry in table Maybe should check application types
   * first to allow application override? Might also be useful to have a flag
   * which indicates table is sorted and we can do a binary search. For now
   * stick to a linear search. */

  for (atbl = adb->tbl, i = 0; i < adb->tblcount; i++, atbl++) ***REMOVED***
    if (atbl->value == selector) ***REMOVED***
      return &atbl->tt;
    ***REMOVED***
  ***REMOVED***

  /* FIXME: need to search application table too */

  /* No match, return default type */
  if (!adb->default_tt) ***REMOVED***
    goto err;
  ***REMOVED***
  return adb->default_tt;

err:
  /* FIXME: should log the value or OID of unsupported type */
  if (nullerr) ***REMOVED***
    OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);
  ***REMOVED***
  return NULL;
***REMOVED***
